// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#include "game.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace webcamshooting {
PROTOBUF_CONSTEXPR Vector3::Vector3(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Vector3DefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vector3DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vector3DefaultTypeInternal() {}
  union {
    Vector3 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vector3DefaultTypeInternal _Vector3_default_instance_;
PROTOBUF_CONSTEXPR Damage::Damage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.damage_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DamageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DamageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DamageDefaultTypeInternal() {}
  union {
    Damage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DamageDefaultTypeInternal _Damage_default_instance_;
PROTOBUF_CONSTEXPR Player::Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.yaw_)*/0
  , /*decltype(_impl_.pitch_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerDefaultTypeInternal() {}
  union {
    Player _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerDefaultTypeInternal _Player_default_instance_;
PROTOBUF_CONSTEXPR ClientUpdate::ClientUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.damages_)*/{}
  , /*decltype(_impl_.pid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.player_)*/nullptr
  , /*decltype(_impl_.fired_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ClientUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientUpdateDefaultTypeInternal() {}
  union {
    ClientUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientUpdateDefaultTypeInternal _ClientUpdate_default_instance_;
PROTOBUF_CONSTEXPR JoinRequest::JoinRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct JoinRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JoinRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JoinRequestDefaultTypeInternal() {}
  union {
    JoinRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinRequestDefaultTypeInternal _JoinRequest_default_instance_;
PROTOBUF_CONSTEXPR DeadUpdate::DeadUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.killed_by_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct DeadUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeadUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeadUpdateDefaultTypeInternal() {}
  union {
    DeadUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeadUpdateDefaultTypeInternal _DeadUpdate_default_instance_;
PROTOBUF_CONSTEXPR RespawnRequest::RespawnRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RespawnRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RespawnRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RespawnRequestDefaultTypeInternal() {}
  union {
    RespawnRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RespawnRequestDefaultTypeInternal _RespawnRequest_default_instance_;
PROTOBUF_CONSTEXPR Request::Request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.request_oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct RequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestDefaultTypeInternal() {}
  union {
    Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestDefaultTypeInternal _Request_default_instance_;
PROTOBUF_CONSTEXPR Response::Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.response_oneof_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseDefaultTypeInternal() {}
  union {
    Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseDefaultTypeInternal _Response_default_instance_;
PROTOBUF_CONSTEXPR PidResponse::PidResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PidResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PidResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PidResponseDefaultTypeInternal() {}
  union {
    PidResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PidResponseDefaultTypeInternal _PidResponse_default_instance_;
PROTOBUF_CONSTEXPR DamageResponse::DamageResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.by_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.amount_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DamageResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DamageResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DamageResponseDefaultTypeInternal() {}
  union {
    DamageResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DamageResponseDefaultTypeInternal _DamageResponse_default_instance_;
PROTOBUF_CONSTEXPR PlayerUpdateResponse::PlayerUpdateResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.damages_)*/{}
  , /*decltype(_impl_.pid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.player_)*/nullptr
  , /*decltype(_impl_.dead_)*/false
  , /*decltype(_impl_.fired_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerUpdateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerUpdateResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerUpdateResponseDefaultTypeInternal() {}
  union {
    PlayerUpdateResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerUpdateResponseDefaultTypeInternal _PlayerUpdateResponse_default_instance_;
PROTOBUF_CONSTEXPR UpdateResponse::UpdateResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateResponseDefaultTypeInternal() {}
  union {
    UpdateResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateResponseDefaultTypeInternal _UpdateResponse_default_instance_;
}  // namespace webcamshooting
static ::_pb::Metadata file_level_metadata_game_2eproto[13];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_game_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_game_2eproto = nullptr;

const uint32_t TableStruct_game_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Vector3, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Vector3, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Vector3, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Vector3, _impl_.z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Damage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Damage, _impl_.pid_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Damage, _impl_.damage_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Player, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Player, _impl_.velocity_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Player, _impl_.yaw_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Player, _impl_.pitch_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::ClientUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::ClientUpdate, _impl_.pid_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::ClientUpdate, _impl_.player_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::ClientUpdate, _impl_.fired_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::ClientUpdate, _impl_.damages_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::JoinRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::JoinRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::DeadUpdate, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::DeadUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::DeadUpdate, _impl_.pid_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::DeadUpdate, _impl_.killed_by_),
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::RespawnRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::RespawnRequest, _impl_.pid_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::RespawnRequest, _impl_.position_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Request, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Request, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Request, _impl_.request_oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Response, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Response, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::webcamshooting::Response, _impl_.response_oneof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::PidResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::PidResponse, _impl_.pid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::DamageResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::DamageResponse, _impl_.by_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::DamageResponse, _impl_.amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::PlayerUpdateResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::PlayerUpdateResponse, _impl_.pid_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::PlayerUpdateResponse, _impl_.player_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::PlayerUpdateResponse, _impl_.dead_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::PlayerUpdateResponse, _impl_.fired_),
  PROTOBUF_FIELD_OFFSET(::webcamshooting::PlayerUpdateResponse, _impl_.damages_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::UpdateResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::webcamshooting::UpdateResponse, _impl_.players_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::webcamshooting::Vector3)},
  { 9, -1, -1, sizeof(::webcamshooting::Damage)},
  { 17, -1, -1, sizeof(::webcamshooting::Player)},
  { 27, -1, -1, sizeof(::webcamshooting::ClientUpdate)},
  { 37, -1, -1, sizeof(::webcamshooting::JoinRequest)},
  { 44, 52, -1, sizeof(::webcamshooting::DeadUpdate)},
  { 54, -1, -1, sizeof(::webcamshooting::RespawnRequest)},
  { 62, -1, -1, sizeof(::webcamshooting::Request)},
  { 73, -1, -1, sizeof(::webcamshooting::Response)},
  { 82, -1, -1, sizeof(::webcamshooting::PidResponse)},
  { 89, -1, -1, sizeof(::webcamshooting::DamageResponse)},
  { 97, -1, -1, sizeof(::webcamshooting::PlayerUpdateResponse)},
  { 108, -1, -1, sizeof(::webcamshooting::UpdateResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::webcamshooting::_Vector3_default_instance_._instance,
  &::webcamshooting::_Damage_default_instance_._instance,
  &::webcamshooting::_Player_default_instance_._instance,
  &::webcamshooting::_ClientUpdate_default_instance_._instance,
  &::webcamshooting::_JoinRequest_default_instance_._instance,
  &::webcamshooting::_DeadUpdate_default_instance_._instance,
  &::webcamshooting::_RespawnRequest_default_instance_._instance,
  &::webcamshooting::_Request_default_instance_._instance,
  &::webcamshooting::_Response_default_instance_._instance,
  &::webcamshooting::_PidResponse_default_instance_._instance,
  &::webcamshooting::_DamageResponse_default_instance_._instance,
  &::webcamshooting::_PlayerUpdateResponse_default_instance_._instance,
  &::webcamshooting::_UpdateResponse_default_instance_._instance,
};

const char descriptor_table_protodef_game_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\ngame.proto\022\016webcamshooting\"*\n\007Vector3\022"
  "\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\"%\n\006Dama"
  "ge\022\013\n\003pid\030\001 \001(\t\022\016\n\006damage\030\002 \001(\002\"z\n\006Playe"
  "r\022)\n\010position\030\001 \001(\0132\027.webcamshooting.Vec"
  "tor3\022)\n\010velocity\030\002 \001(\0132\027.webcamshooting."
  "Vector3\022\013\n\003yaw\030\003 \001(\002\022\r\n\005pitch\030\004 \001(\002\"{\n\014C"
  "lientUpdate\022\013\n\003pid\030\001 \001(\t\022&\n\006player\030\002 \001(\013"
  "2\026.webcamshooting.Player\022\r\n\005fired\030\003 \001(\010\022"
  "\'\n\007damages\030\004 \003(\0132\026.webcamshooting.Damage"
  "\"\033\n\013JoinRequest\022\014\n\004name\030\001 \001(\t\"\?\n\nDeadUpd"
  "ate\022\013\n\003pid\030\001 \001(\t\022\026\n\tkilled_by\030\002 \001(\tH\000\210\001\001"
  "B\014\n\n_killed_by\"H\n\016RespawnRequest\022\013\n\003pid\030"
  "\001 \001(\t\022)\n\010position\030\002 \001(\0132\027.webcamshooting"
  ".Vector3\"\364\001\n\007Request\0223\n\014join_request\030\001 \001"
  "(\0132\033.webcamshooting.JoinRequestH\000\0225\n\rcli"
  "ent_update\030\002 \001(\0132\034.webcamshooting.Client"
  "UpdateH\000\0221\n\013dead_update\030\003 \001(\0132\032.webcamsh"
  "ooting.DeadUpdateH\000\0229\n\017respawn_request\030\004"
  " \001(\0132\036.webcamshooting.RespawnRequestH\000B\017"
  "\n\rrequest_oneof\"\214\001\n\010Response\0223\n\014pid_resp"
  "onse\030\001 \001(\0132\033.webcamshooting.PidResponseH"
  "\000\0229\n\017update_response\030\002 \001(\0132\036.webcamshoot"
  "ing.UpdateResponseH\000B\020\n\016response_oneof\"\032"
  "\n\013PidResponse\022\013\n\003pid\030\001 \001(\t\",\n\016DamageResp"
  "onse\022\n\n\002by\030\001 \001(\t\022\016\n\006amount\030\002 \001(\002\"\231\001\n\024Pla"
  "yerUpdateResponse\022\013\n\003pid\030\001 \001(\t\022&\n\006player"
  "\030\002 \001(\0132\026.webcamshooting.Player\022\014\n\004dead\030\003"
  " \001(\010\022\r\n\005fired\030\006 \001(\010\022/\n\007damages\030\007 \003(\0132\036.w"
  "ebcamshooting.DamageResponse\"G\n\016UpdateRe"
  "sponse\0225\n\007players\030\001 \003(\0132$.webcamshooting"
  ".PlayerUpdateResponseB0Z.github.com/kani"
  "creampasta/webcamshooting/typesb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_game_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_game_2eproto = {
    false, false, 1279, descriptor_table_protodef_game_2eproto,
    "game.proto",
    &descriptor_table_game_2eproto_once, nullptr, 0, 13,
    schemas, file_default_instances, TableStruct_game_2eproto::offsets,
    file_level_metadata_game_2eproto, file_level_enum_descriptors_game_2eproto,
    file_level_service_descriptors_game_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_game_2eproto_getter() {
  return &descriptor_table_game_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_game_2eproto(&descriptor_table_game_2eproto);
namespace webcamshooting {

// ===================================================================

class Vector3::_Internal {
 public:
};

Vector3::Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.Vector3)
}
Vector3::Vector3(const Vector3& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vector3* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:webcamshooting.Vector3)
}

inline void Vector3::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Vector3::~Vector3() {
  // @@protoc_insertion_point(destructor:webcamshooting.Vector3)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vector3::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vector3::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vector3::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.Vector3)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector3::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vector3::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.Vector3)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.Vector3)
  return target;
}

size_t Vector3::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.Vector3)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vector3::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vector3::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vector3::GetClassData() const { return &_class_data_; }


void Vector3::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vector3*>(&to_msg);
  auto& from = static_cast<const Vector3&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.Vector3)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vector3::CopyFrom(const Vector3& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.Vector3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector3::IsInitialized() const {
  return true;
}

void Vector3::InternalSwap(Vector3* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector3, _impl_.z_)
      + sizeof(Vector3::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Vector3, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector3::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[0]);
}

// ===================================================================

class Damage::_Internal {
 public:
};

Damage::Damage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.Damage)
}
Damage::Damage(const Damage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Damage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pid_){}
    , decltype(_impl_.damage_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pid().empty()) {
    _this->_impl_.pid_.Set(from._internal_pid(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.damage_ = from._impl_.damage_;
  // @@protoc_insertion_point(copy_constructor:webcamshooting.Damage)
}

inline void Damage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pid_){}
    , decltype(_impl_.damage_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.pid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Damage::~Damage() {
  // @@protoc_insertion_point(destructor:webcamshooting.Damage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Damage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pid_.Destroy();
}

void Damage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Damage::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.Damage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pid_.ClearToEmpty();
  _impl_.damage_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Damage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "webcamshooting.Damage.pid"));
        } else
          goto handle_unusual;
        continue;
      // float damage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.damage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Damage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.Damage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string pid = 1;
  if (!this->_internal_pid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pid().data(), static_cast<int>(this->_internal_pid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "webcamshooting.Damage.pid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_pid(), target);
  }

  // float damage = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_damage = this->_internal_damage();
  uint32_t raw_damage;
  memcpy(&raw_damage, &tmp_damage, sizeof(tmp_damage));
  if (raw_damage != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_damage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.Damage)
  return target;
}

size_t Damage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.Damage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string pid = 1;
  if (!this->_internal_pid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pid());
  }

  // float damage = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_damage = this->_internal_damage();
  uint32_t raw_damage;
  memcpy(&raw_damage, &tmp_damage, sizeof(tmp_damage));
  if (raw_damage != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Damage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Damage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Damage::GetClassData() const { return &_class_data_; }


void Damage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Damage*>(&to_msg);
  auto& from = static_cast<const Damage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.Damage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_pid().empty()) {
    _this->_internal_set_pid(from._internal_pid());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_damage = from._internal_damage();
  uint32_t raw_damage;
  memcpy(&raw_damage, &tmp_damage, sizeof(tmp_damage));
  if (raw_damage != 0) {
    _this->_internal_set_damage(from._internal_damage());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Damage::CopyFrom(const Damage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.Damage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Damage::IsInitialized() const {
  return true;
}

void Damage::InternalSwap(Damage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pid_, lhs_arena,
      &other->_impl_.pid_, rhs_arena
  );
  swap(_impl_.damage_, other->_impl_.damage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Damage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[1]);
}

// ===================================================================

class Player::_Internal {
 public:
  static const ::webcamshooting::Vector3& position(const Player* msg);
  static const ::webcamshooting::Vector3& velocity(const Player* msg);
};

const ::webcamshooting::Vector3&
Player::_Internal::position(const Player* msg) {
  return *msg->_impl_.position_;
}
const ::webcamshooting::Vector3&
Player::_Internal::velocity(const Player* msg) {
  return *msg->_impl_.velocity_;
}
Player::Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.Player)
}
Player::Player(const Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.yaw_){}
    , decltype(_impl_.pitch_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::webcamshooting::Vector3(*from._impl_.position_);
  }
  if (from._internal_has_velocity()) {
    _this->_impl_.velocity_ = new ::webcamshooting::Vector3(*from._impl_.velocity_);
  }
  ::memcpy(&_impl_.yaw_, &from._impl_.yaw_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pitch_) -
    reinterpret_cast<char*>(&_impl_.yaw_)) + sizeof(_impl_.pitch_));
  // @@protoc_insertion_point(copy_constructor:webcamshooting.Player)
}

inline void Player::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.yaw_){0}
    , decltype(_impl_.pitch_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Player::~Player() {
  // @@protoc_insertion_point(destructor:webcamshooting.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Player::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
}

void Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Player::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.Player)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr) {
    delete _impl_.velocity_;
  }
  _impl_.velocity_ = nullptr;
  ::memset(&_impl_.yaw_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.pitch_) -
      reinterpret_cast<char*>(&_impl_.yaw_)) + sizeof(_impl_.pitch_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .webcamshooting.Vector3 position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .webcamshooting.Vector3 velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float yaw = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pitch = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.pitch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Player::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.Player)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .webcamshooting.Vector3 position = 1;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .webcamshooting.Vector3 velocity = 2;
  if (this->_internal_has_velocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // float yaw = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = this->_internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_yaw(), target);
  }

  // float pitch = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = this->_internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_pitch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.Player)
  return target;
}

size_t Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.Player)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .webcamshooting.Vector3 position = 1;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // .webcamshooting.Vector3 velocity = 2;
  if (this->_internal_has_velocity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.velocity_);
  }

  // float yaw = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = this->_internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    total_size += 1 + 4;
  }

  // float pitch = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = this->_internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Player::GetClassData() const { return &_class_data_; }


void Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Player*>(&to_msg);
  auto& from = static_cast<const Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.Player)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::webcamshooting::Vector3::MergeFrom(
        from._internal_position());
  }
  if (from._internal_has_velocity()) {
    _this->_internal_mutable_velocity()->::webcamshooting::Vector3::MergeFrom(
        from._internal_velocity());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = from._internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    _this->_internal_set_yaw(from._internal_yaw());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = from._internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    _this->_internal_set_pitch(from._internal_pitch());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Player::CopyFrom(const Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Player::IsInitialized() const {
  return true;
}

void Player::InternalSwap(Player* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Player, _impl_.pitch_)
      + sizeof(Player::_impl_.pitch_)
      - PROTOBUF_FIELD_OFFSET(Player, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[2]);
}

// ===================================================================

class ClientUpdate::_Internal {
 public:
  static const ::webcamshooting::Player& player(const ClientUpdate* msg);
};

const ::webcamshooting::Player&
ClientUpdate::_Internal::player(const ClientUpdate* msg) {
  return *msg->_impl_.player_;
}
ClientUpdate::ClientUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.ClientUpdate)
}
ClientUpdate::ClientUpdate(const ClientUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClientUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.damages_){from._impl_.damages_}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.player_){nullptr}
    , decltype(_impl_.fired_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pid().empty()) {
    _this->_impl_.pid_.Set(from._internal_pid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_player()) {
    _this->_impl_.player_ = new ::webcamshooting::Player(*from._impl_.player_);
  }
  _this->_impl_.fired_ = from._impl_.fired_;
  // @@protoc_insertion_point(copy_constructor:webcamshooting.ClientUpdate)
}

inline void ClientUpdate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.damages_){arena}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.player_){nullptr}
    , decltype(_impl_.fired_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.pid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientUpdate::~ClientUpdate() {
  // @@protoc_insertion_point(destructor:webcamshooting.ClientUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.damages_.~RepeatedPtrField();
  _impl_.pid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.player_;
}

void ClientUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.ClientUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.damages_.Clear();
  _impl_.pid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
  _impl_.fired_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClientUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "webcamshooting.ClientUpdate.pid"));
        } else
          goto handle_unusual;
        continue;
      // .webcamshooting.Player player = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_player(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool fired = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.fired_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .webcamshooting.Damage damages = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_damages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.ClientUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string pid = 1;
  if (!this->_internal_pid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pid().data(), static_cast<int>(this->_internal_pid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "webcamshooting.ClientUpdate.pid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_pid(), target);
  }

  // .webcamshooting.Player player = 2;
  if (this->_internal_has_player()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::player(this),
        _Internal::player(this).GetCachedSize(), target, stream);
  }

  // bool fired = 3;
  if (this->_internal_fired() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_fired(), target);
  }

  // repeated .webcamshooting.Damage damages = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_damages_size()); i < n; i++) {
    const auto& repfield = this->_internal_damages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.ClientUpdate)
  return target;
}

size_t ClientUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.ClientUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .webcamshooting.Damage damages = 4;
  total_size += 1UL * this->_internal_damages_size();
  for (const auto& msg : this->_impl_.damages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string pid = 1;
  if (!this->_internal_pid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pid());
  }

  // .webcamshooting.Player player = 2;
  if (this->_internal_has_player()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_);
  }

  // bool fired = 3;
  if (this->_internal_fired() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClientUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClientUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClientUpdate::GetClassData() const { return &_class_data_; }


void ClientUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClientUpdate*>(&to_msg);
  auto& from = static_cast<const ClientUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.ClientUpdate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.damages_.MergeFrom(from._impl_.damages_);
  if (!from._internal_pid().empty()) {
    _this->_internal_set_pid(from._internal_pid());
  }
  if (from._internal_has_player()) {
    _this->_internal_mutable_player()->::webcamshooting::Player::MergeFrom(
        from._internal_player());
  }
  if (from._internal_fired() != 0) {
    _this->_internal_set_fired(from._internal_fired());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClientUpdate::CopyFrom(const ClientUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.ClientUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientUpdate::IsInitialized() const {
  return true;
}

void ClientUpdate::InternalSwap(ClientUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.damages_.InternalSwap(&other->_impl_.damages_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pid_, lhs_arena,
      &other->_impl_.pid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientUpdate, _impl_.fired_)
      + sizeof(ClientUpdate::_impl_.fired_)
      - PROTOBUF_FIELD_OFFSET(ClientUpdate, _impl_.player_)>(
          reinterpret_cast<char*>(&_impl_.player_),
          reinterpret_cast<char*>(&other->_impl_.player_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ClientUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[3]);
}

// ===================================================================

class JoinRequest::_Internal {
 public:
};

JoinRequest::JoinRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.JoinRequest)
}
JoinRequest::JoinRequest(const JoinRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  JoinRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:webcamshooting.JoinRequest)
}

inline void JoinRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

JoinRequest::~JoinRequest() {
  // @@protoc_insertion_point(destructor:webcamshooting.JoinRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void JoinRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void JoinRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void JoinRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.JoinRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* JoinRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "webcamshooting.JoinRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.JoinRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "webcamshooting.JoinRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.JoinRequest)
  return target;
}

size_t JoinRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.JoinRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData JoinRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    JoinRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*JoinRequest::GetClassData() const { return &_class_data_; }


void JoinRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<JoinRequest*>(&to_msg);
  auto& from = static_cast<const JoinRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.JoinRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void JoinRequest::CopyFrom(const JoinRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.JoinRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinRequest::IsInitialized() const {
  return true;
}

void JoinRequest::InternalSwap(JoinRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata JoinRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[4]);
}

// ===================================================================

class DeadUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<DeadUpdate>()._impl_._has_bits_);
  static void set_has_killed_by(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DeadUpdate::DeadUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.DeadUpdate)
}
DeadUpdate::DeadUpdate(const DeadUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeadUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.killed_by_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pid().empty()) {
    _this->_impl_.pid_.Set(from._internal_pid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.killed_by_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.killed_by_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_killed_by()) {
    _this->_impl_.killed_by_.Set(from._internal_killed_by(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:webcamshooting.DeadUpdate)
}

inline void DeadUpdate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.killed_by_){}
  };
  _impl_.pid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.killed_by_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.killed_by_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeadUpdate::~DeadUpdate() {
  // @@protoc_insertion_point(destructor:webcamshooting.DeadUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeadUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pid_.Destroy();
  _impl_.killed_by_.Destroy();
}

void DeadUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeadUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.DeadUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pid_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.killed_by_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeadUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "webcamshooting.DeadUpdate.pid"));
        } else
          goto handle_unusual;
        continue;
      // optional string killed_by = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_killed_by();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "webcamshooting.DeadUpdate.killed_by"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeadUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.DeadUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string pid = 1;
  if (!this->_internal_pid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pid().data(), static_cast<int>(this->_internal_pid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "webcamshooting.DeadUpdate.pid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_pid(), target);
  }

  // optional string killed_by = 2;
  if (_internal_has_killed_by()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_killed_by().data(), static_cast<int>(this->_internal_killed_by().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "webcamshooting.DeadUpdate.killed_by");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_killed_by(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.DeadUpdate)
  return target;
}

size_t DeadUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.DeadUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string pid = 1;
  if (!this->_internal_pid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pid());
  }

  // optional string killed_by = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_killed_by());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeadUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeadUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeadUpdate::GetClassData() const { return &_class_data_; }


void DeadUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeadUpdate*>(&to_msg);
  auto& from = static_cast<const DeadUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.DeadUpdate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_pid().empty()) {
    _this->_internal_set_pid(from._internal_pid());
  }
  if (from._internal_has_killed_by()) {
    _this->_internal_set_killed_by(from._internal_killed_by());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeadUpdate::CopyFrom(const DeadUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.DeadUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeadUpdate::IsInitialized() const {
  return true;
}

void DeadUpdate::InternalSwap(DeadUpdate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pid_, lhs_arena,
      &other->_impl_.pid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.killed_by_, lhs_arena,
      &other->_impl_.killed_by_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DeadUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[5]);
}

// ===================================================================

class RespawnRequest::_Internal {
 public:
  static const ::webcamshooting::Vector3& position(const RespawnRequest* msg);
};

const ::webcamshooting::Vector3&
RespawnRequest::_Internal::position(const RespawnRequest* msg) {
  return *msg->_impl_.position_;
}
RespawnRequest::RespawnRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.RespawnRequest)
}
RespawnRequest::RespawnRequest(const RespawnRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RespawnRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pid_){}
    , decltype(_impl_.position_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pid().empty()) {
    _this->_impl_.pid_.Set(from._internal_pid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::webcamshooting::Vector3(*from._impl_.position_);
  }
  // @@protoc_insertion_point(copy_constructor:webcamshooting.RespawnRequest)
}

inline void RespawnRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pid_){}
    , decltype(_impl_.position_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.pid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RespawnRequest::~RespawnRequest() {
  // @@protoc_insertion_point(destructor:webcamshooting.RespawnRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RespawnRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.position_;
}

void RespawnRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RespawnRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.RespawnRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RespawnRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "webcamshooting.RespawnRequest.pid"));
        } else
          goto handle_unusual;
        continue;
      // .webcamshooting.Vector3 position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RespawnRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.RespawnRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string pid = 1;
  if (!this->_internal_pid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pid().data(), static_cast<int>(this->_internal_pid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "webcamshooting.RespawnRequest.pid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_pid(), target);
  }

  // .webcamshooting.Vector3 position = 2;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.RespawnRequest)
  return target;
}

size_t RespawnRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.RespawnRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string pid = 1;
  if (!this->_internal_pid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pid());
  }

  // .webcamshooting.Vector3 position = 2;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RespawnRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RespawnRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RespawnRequest::GetClassData() const { return &_class_data_; }


void RespawnRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RespawnRequest*>(&to_msg);
  auto& from = static_cast<const RespawnRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.RespawnRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_pid().empty()) {
    _this->_internal_set_pid(from._internal_pid());
  }
  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::webcamshooting::Vector3::MergeFrom(
        from._internal_position());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RespawnRequest::CopyFrom(const RespawnRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.RespawnRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RespawnRequest::IsInitialized() const {
  return true;
}

void RespawnRequest::InternalSwap(RespawnRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pid_, lhs_arena,
      &other->_impl_.pid_, rhs_arena
  );
  swap(_impl_.position_, other->_impl_.position_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RespawnRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[6]);
}

// ===================================================================

class Request::_Internal {
 public:
  static const ::webcamshooting::JoinRequest& join_request(const Request* msg);
  static const ::webcamshooting::ClientUpdate& client_update(const Request* msg);
  static const ::webcamshooting::DeadUpdate& dead_update(const Request* msg);
  static const ::webcamshooting::RespawnRequest& respawn_request(const Request* msg);
};

const ::webcamshooting::JoinRequest&
Request::_Internal::join_request(const Request* msg) {
  return *msg->_impl_.request_oneof_.join_request_;
}
const ::webcamshooting::ClientUpdate&
Request::_Internal::client_update(const Request* msg) {
  return *msg->_impl_.request_oneof_.client_update_;
}
const ::webcamshooting::DeadUpdate&
Request::_Internal::dead_update(const Request* msg) {
  return *msg->_impl_.request_oneof_.dead_update_;
}
const ::webcamshooting::RespawnRequest&
Request::_Internal::respawn_request(const Request* msg) {
  return *msg->_impl_.request_oneof_.respawn_request_;
}
void Request::set_allocated_join_request(::webcamshooting::JoinRequest* join_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request_oneof();
  if (join_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(join_request);
    if (message_arena != submessage_arena) {
      join_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, join_request, submessage_arena);
    }
    set_has_join_request();
    _impl_.request_oneof_.join_request_ = join_request;
  }
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.Request.join_request)
}
void Request::set_allocated_client_update(::webcamshooting::ClientUpdate* client_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request_oneof();
  if (client_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_update);
    if (message_arena != submessage_arena) {
      client_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_update, submessage_arena);
    }
    set_has_client_update();
    _impl_.request_oneof_.client_update_ = client_update;
  }
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.Request.client_update)
}
void Request::set_allocated_dead_update(::webcamshooting::DeadUpdate* dead_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request_oneof();
  if (dead_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dead_update);
    if (message_arena != submessage_arena) {
      dead_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dead_update, submessage_arena);
    }
    set_has_dead_update();
    _impl_.request_oneof_.dead_update_ = dead_update;
  }
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.Request.dead_update)
}
void Request::set_allocated_respawn_request(::webcamshooting::RespawnRequest* respawn_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request_oneof();
  if (respawn_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(respawn_request);
    if (message_arena != submessage_arena) {
      respawn_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, respawn_request, submessage_arena);
    }
    set_has_respawn_request();
    _impl_.request_oneof_.respawn_request_ = respawn_request;
  }
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.Request.respawn_request)
}
Request::Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.Request)
}
Request::Request(const Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.request_oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_request_oneof();
  switch (from.request_oneof_case()) {
    case kJoinRequest: {
      _this->_internal_mutable_join_request()->::webcamshooting::JoinRequest::MergeFrom(
          from._internal_join_request());
      break;
    }
    case kClientUpdate: {
      _this->_internal_mutable_client_update()->::webcamshooting::ClientUpdate::MergeFrom(
          from._internal_client_update());
      break;
    }
    case kDeadUpdate: {
      _this->_internal_mutable_dead_update()->::webcamshooting::DeadUpdate::MergeFrom(
          from._internal_dead_update());
      break;
    }
    case kRespawnRequest: {
      _this->_internal_mutable_respawn_request()->::webcamshooting::RespawnRequest::MergeFrom(
          from._internal_respawn_request());
      break;
    }
    case REQUEST_ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:webcamshooting.Request)
}

inline void Request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.request_oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_request_oneof();
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:webcamshooting.Request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_request_oneof()) {
    clear_request_oneof();
  }
}

void Request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Request::clear_request_oneof() {
// @@protoc_insertion_point(one_of_clear_start:webcamshooting.Request)
  switch (request_oneof_case()) {
    case kJoinRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_oneof_.join_request_;
      }
      break;
    }
    case kClientUpdate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_oneof_.client_update_;
      }
      break;
    }
    case kDeadUpdate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_oneof_.dead_update_;
      }
      break;
    }
    case kRespawnRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.request_oneof_.respawn_request_;
      }
      break;
    }
    case REQUEST_ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = REQUEST_ONEOF_NOT_SET;
}


void Request::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_request_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .webcamshooting.JoinRequest join_request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_join_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .webcamshooting.ClientUpdate client_update = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_update(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .webcamshooting.DeadUpdate dead_update = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_dead_update(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .webcamshooting.RespawnRequest respawn_request = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_respawn_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .webcamshooting.JoinRequest join_request = 1;
  if (_internal_has_join_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::join_request(this),
        _Internal::join_request(this).GetCachedSize(), target, stream);
  }

  // .webcamshooting.ClientUpdate client_update = 2;
  if (_internal_has_client_update()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::client_update(this),
        _Internal::client_update(this).GetCachedSize(), target, stream);
  }

  // .webcamshooting.DeadUpdate dead_update = 3;
  if (_internal_has_dead_update()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::dead_update(this),
        _Internal::dead_update(this).GetCachedSize(), target, stream);
  }

  // .webcamshooting.RespawnRequest respawn_request = 4;
  if (_internal_has_respawn_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::respawn_request(this),
        _Internal::respawn_request(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.Request)
  return target;
}

size_t Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (request_oneof_case()) {
    // .webcamshooting.JoinRequest join_request = 1;
    case kJoinRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_oneof_.join_request_);
      break;
    }
    // .webcamshooting.ClientUpdate client_update = 2;
    case kClientUpdate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_oneof_.client_update_);
      break;
    }
    // .webcamshooting.DeadUpdate dead_update = 3;
    case kDeadUpdate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_oneof_.dead_update_);
      break;
    }
    // .webcamshooting.RespawnRequest respawn_request = 4;
    case kRespawnRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_oneof_.respawn_request_);
      break;
    }
    case REQUEST_ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Request::GetClassData() const { return &_class_data_; }


void Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Request*>(&to_msg);
  auto& from = static_cast<const Request&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.Request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.request_oneof_case()) {
    case kJoinRequest: {
      _this->_internal_mutable_join_request()->::webcamshooting::JoinRequest::MergeFrom(
          from._internal_join_request());
      break;
    }
    case kClientUpdate: {
      _this->_internal_mutable_client_update()->::webcamshooting::ClientUpdate::MergeFrom(
          from._internal_client_update());
      break;
    }
    case kDeadUpdate: {
      _this->_internal_mutable_dead_update()->::webcamshooting::DeadUpdate::MergeFrom(
          from._internal_dead_update());
      break;
    }
    case kRespawnRequest: {
      _this->_internal_mutable_respawn_request()->::webcamshooting::RespawnRequest::MergeFrom(
          from._internal_respawn_request());
      break;
    }
    case REQUEST_ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Request::CopyFrom(const Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {
  return true;
}

void Request::InternalSwap(Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.request_oneof_, other->_impl_.request_oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Request::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[7]);
}

// ===================================================================

class Response::_Internal {
 public:
  static const ::webcamshooting::PidResponse& pid_response(const Response* msg);
  static const ::webcamshooting::UpdateResponse& update_response(const Response* msg);
};

const ::webcamshooting::PidResponse&
Response::_Internal::pid_response(const Response* msg) {
  return *msg->_impl_.response_oneof_.pid_response_;
}
const ::webcamshooting::UpdateResponse&
Response::_Internal::update_response(const Response* msg) {
  return *msg->_impl_.response_oneof_.update_response_;
}
void Response::set_allocated_pid_response(::webcamshooting::PidResponse* pid_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response_oneof();
  if (pid_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pid_response);
    if (message_arena != submessage_arena) {
      pid_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pid_response, submessage_arena);
    }
    set_has_pid_response();
    _impl_.response_oneof_.pid_response_ = pid_response;
  }
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.Response.pid_response)
}
void Response::set_allocated_update_response(::webcamshooting::UpdateResponse* update_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_response_oneof();
  if (update_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(update_response);
    if (message_arena != submessage_arena) {
      update_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_response, submessage_arena);
    }
    set_has_update_response();
    _impl_.response_oneof_.update_response_ = update_response;
  }
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.Response.update_response)
}
Response::Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.Response)
}
Response::Response(const Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.response_oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_response_oneof();
  switch (from.response_oneof_case()) {
    case kPidResponse: {
      _this->_internal_mutable_pid_response()->::webcamshooting::PidResponse::MergeFrom(
          from._internal_pid_response());
      break;
    }
    case kUpdateResponse: {
      _this->_internal_mutable_update_response()->::webcamshooting::UpdateResponse::MergeFrom(
          from._internal_update_response());
      break;
    }
    case RESPONSE_ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:webcamshooting.Response)
}

inline void Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.response_oneof_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_response_oneof();
}

Response::~Response() {
  // @@protoc_insertion_point(destructor:webcamshooting.Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_response_oneof()) {
    clear_response_oneof();
  }
}

void Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Response::clear_response_oneof() {
// @@protoc_insertion_point(one_of_clear_start:webcamshooting.Response)
  switch (response_oneof_case()) {
    case kPidResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_oneof_.pid_response_;
      }
      break;
    }
    case kUpdateResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.response_oneof_.update_response_;
      }
      break;
    }
    case RESPONSE_ONEOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RESPONSE_ONEOF_NOT_SET;
}


void Response::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_response_oneof();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .webcamshooting.PidResponse pid_response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pid_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .webcamshooting.UpdateResponse update_response = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .webcamshooting.PidResponse pid_response = 1;
  if (_internal_has_pid_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pid_response(this),
        _Internal::pid_response(this).GetCachedSize(), target, stream);
  }

  // .webcamshooting.UpdateResponse update_response = 2;
  if (_internal_has_update_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_response(this),
        _Internal::update_response(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.Response)
  return target;
}

size_t Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (response_oneof_case()) {
    // .webcamshooting.PidResponse pid_response = 1;
    case kPidResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_oneof_.pid_response_);
      break;
    }
    // .webcamshooting.UpdateResponse update_response = 2;
    case kUpdateResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_oneof_.update_response_);
      break;
    }
    case RESPONSE_ONEOF_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Response::GetClassData() const { return &_class_data_; }


void Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Response*>(&to_msg);
  auto& from = static_cast<const Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.response_oneof_case()) {
    case kPidResponse: {
      _this->_internal_mutable_pid_response()->::webcamshooting::PidResponse::MergeFrom(
          from._internal_pid_response());
      break;
    }
    case kUpdateResponse: {
      _this->_internal_mutable_update_response()->::webcamshooting::UpdateResponse::MergeFrom(
          from._internal_update_response());
      break;
    }
    case RESPONSE_ONEOF_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Response::CopyFrom(const Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Response::IsInitialized() const {
  return true;
}

void Response::InternalSwap(Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.response_oneof_, other->_impl_.response_oneof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[8]);
}

// ===================================================================

class PidResponse::_Internal {
 public:
};

PidResponse::PidResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.PidResponse)
}
PidResponse::PidResponse(const PidResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PidResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pid().empty()) {
    _this->_impl_.pid_.Set(from._internal_pid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:webcamshooting.PidResponse)
}

inline void PidResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pid_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.pid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PidResponse::~PidResponse() {
  // @@protoc_insertion_point(destructor:webcamshooting.PidResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PidResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pid_.Destroy();
}

void PidResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PidResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.PidResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pid_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PidResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "webcamshooting.PidResponse.pid"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PidResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.PidResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string pid = 1;
  if (!this->_internal_pid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pid().data(), static_cast<int>(this->_internal_pid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "webcamshooting.PidResponse.pid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.PidResponse)
  return target;
}

size_t PidResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.PidResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string pid = 1;
  if (!this->_internal_pid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PidResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PidResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PidResponse::GetClassData() const { return &_class_data_; }


void PidResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PidResponse*>(&to_msg);
  auto& from = static_cast<const PidResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.PidResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_pid().empty()) {
    _this->_internal_set_pid(from._internal_pid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PidResponse::CopyFrom(const PidResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.PidResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PidResponse::IsInitialized() const {
  return true;
}

void PidResponse::InternalSwap(PidResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pid_, lhs_arena,
      &other->_impl_.pid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PidResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[9]);
}

// ===================================================================

class DamageResponse::_Internal {
 public:
};

DamageResponse::DamageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.DamageResponse)
}
DamageResponse::DamageResponse(const DamageResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DamageResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.by_){}
    , decltype(_impl_.amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.by_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.by_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_by().empty()) {
    _this->_impl_.by_.Set(from._internal_by(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.amount_ = from._impl_.amount_;
  // @@protoc_insertion_point(copy_constructor:webcamshooting.DamageResponse)
}

inline void DamageResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.by_){}
    , decltype(_impl_.amount_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.by_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.by_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DamageResponse::~DamageResponse() {
  // @@protoc_insertion_point(destructor:webcamshooting.DamageResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DamageResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.by_.Destroy();
}

void DamageResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DamageResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.DamageResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.by_.ClearToEmpty();
  _impl_.amount_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DamageResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string by = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_by();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "webcamshooting.DamageResponse.by"));
        } else
          goto handle_unusual;
        continue;
      // float amount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DamageResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.DamageResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string by = 1;
  if (!this->_internal_by().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_by().data(), static_cast<int>(this->_internal_by().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "webcamshooting.DamageResponse.by");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_by(), target);
  }

  // float amount = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_amount = this->_internal_amount();
  uint32_t raw_amount;
  memcpy(&raw_amount, &tmp_amount, sizeof(tmp_amount));
  if (raw_amount != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.DamageResponse)
  return target;
}

size_t DamageResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.DamageResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string by = 1;
  if (!this->_internal_by().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_by());
  }

  // float amount = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_amount = this->_internal_amount();
  uint32_t raw_amount;
  memcpy(&raw_amount, &tmp_amount, sizeof(tmp_amount));
  if (raw_amount != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DamageResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DamageResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DamageResponse::GetClassData() const { return &_class_data_; }


void DamageResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DamageResponse*>(&to_msg);
  auto& from = static_cast<const DamageResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.DamageResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_by().empty()) {
    _this->_internal_set_by(from._internal_by());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_amount = from._internal_amount();
  uint32_t raw_amount;
  memcpy(&raw_amount, &tmp_amount, sizeof(tmp_amount));
  if (raw_amount != 0) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DamageResponse::CopyFrom(const DamageResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.DamageResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DamageResponse::IsInitialized() const {
  return true;
}

void DamageResponse::InternalSwap(DamageResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.by_, lhs_arena,
      &other->_impl_.by_, rhs_arena
  );
  swap(_impl_.amount_, other->_impl_.amount_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DamageResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[10]);
}

// ===================================================================

class PlayerUpdateResponse::_Internal {
 public:
  static const ::webcamshooting::Player& player(const PlayerUpdateResponse* msg);
};

const ::webcamshooting::Player&
PlayerUpdateResponse::_Internal::player(const PlayerUpdateResponse* msg) {
  return *msg->_impl_.player_;
}
PlayerUpdateResponse::PlayerUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.PlayerUpdateResponse)
}
PlayerUpdateResponse::PlayerUpdateResponse(const PlayerUpdateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerUpdateResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.damages_){from._impl_.damages_}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.player_){nullptr}
    , decltype(_impl_.dead_){}
    , decltype(_impl_.fired_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pid().empty()) {
    _this->_impl_.pid_.Set(from._internal_pid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_player()) {
    _this->_impl_.player_ = new ::webcamshooting::Player(*from._impl_.player_);
  }
  ::memcpy(&_impl_.dead_, &from._impl_.dead_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fired_) -
    reinterpret_cast<char*>(&_impl_.dead_)) + sizeof(_impl_.fired_));
  // @@protoc_insertion_point(copy_constructor:webcamshooting.PlayerUpdateResponse)
}

inline void PlayerUpdateResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.damages_){arena}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.player_){nullptr}
    , decltype(_impl_.dead_){false}
    , decltype(_impl_.fired_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.pid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlayerUpdateResponse::~PlayerUpdateResponse() {
  // @@protoc_insertion_point(destructor:webcamshooting.PlayerUpdateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerUpdateResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.damages_.~RepeatedPtrField();
  _impl_.pid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.player_;
}

void PlayerUpdateResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerUpdateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.PlayerUpdateResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.damages_.Clear();
  _impl_.pid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
  ::memset(&_impl_.dead_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.fired_) -
      reinterpret_cast<char*>(&_impl_.dead_)) + sizeof(_impl_.fired_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerUpdateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "webcamshooting.PlayerUpdateResponse.pid"));
        } else
          goto handle_unusual;
        continue;
      // .webcamshooting.Player player = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_player(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool dead = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.dead_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool fired = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.fired_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .webcamshooting.DamageResponse damages = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_damages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerUpdateResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.PlayerUpdateResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string pid = 1;
  if (!this->_internal_pid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pid().data(), static_cast<int>(this->_internal_pid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "webcamshooting.PlayerUpdateResponse.pid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_pid(), target);
  }

  // .webcamshooting.Player player = 2;
  if (this->_internal_has_player()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::player(this),
        _Internal::player(this).GetCachedSize(), target, stream);
  }

  // bool dead = 3;
  if (this->_internal_dead() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_dead(), target);
  }

  // bool fired = 6;
  if (this->_internal_fired() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_fired(), target);
  }

  // repeated .webcamshooting.DamageResponse damages = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_damages_size()); i < n; i++) {
    const auto& repfield = this->_internal_damages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.PlayerUpdateResponse)
  return target;
}

size_t PlayerUpdateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.PlayerUpdateResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .webcamshooting.DamageResponse damages = 7;
  total_size += 1UL * this->_internal_damages_size();
  for (const auto& msg : this->_impl_.damages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string pid = 1;
  if (!this->_internal_pid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pid());
  }

  // .webcamshooting.Player player = 2;
  if (this->_internal_has_player()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_);
  }

  // bool dead = 3;
  if (this->_internal_dead() != 0) {
    total_size += 1 + 1;
  }

  // bool fired = 6;
  if (this->_internal_fired() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerUpdateResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerUpdateResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerUpdateResponse::GetClassData() const { return &_class_data_; }


void PlayerUpdateResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerUpdateResponse*>(&to_msg);
  auto& from = static_cast<const PlayerUpdateResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.PlayerUpdateResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.damages_.MergeFrom(from._impl_.damages_);
  if (!from._internal_pid().empty()) {
    _this->_internal_set_pid(from._internal_pid());
  }
  if (from._internal_has_player()) {
    _this->_internal_mutable_player()->::webcamshooting::Player::MergeFrom(
        from._internal_player());
  }
  if (from._internal_dead() != 0) {
    _this->_internal_set_dead(from._internal_dead());
  }
  if (from._internal_fired() != 0) {
    _this->_internal_set_fired(from._internal_fired());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerUpdateResponse::CopyFrom(const PlayerUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.PlayerUpdateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerUpdateResponse::IsInitialized() const {
  return true;
}

void PlayerUpdateResponse::InternalSwap(PlayerUpdateResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.damages_.InternalSwap(&other->_impl_.damages_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pid_, lhs_arena,
      &other->_impl_.pid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerUpdateResponse, _impl_.fired_)
      + sizeof(PlayerUpdateResponse::_impl_.fired_)
      - PROTOBUF_FIELD_OFFSET(PlayerUpdateResponse, _impl_.player_)>(
          reinterpret_cast<char*>(&_impl_.player_),
          reinterpret_cast<char*>(&other->_impl_.player_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerUpdateResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[11]);
}

// ===================================================================

class UpdateResponse::_Internal {
 public:
};

UpdateResponse::UpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:webcamshooting.UpdateResponse)
}
UpdateResponse::UpdateResponse(const UpdateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.players_){from._impl_.players_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:webcamshooting.UpdateResponse)
}

inline void UpdateResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.players_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateResponse::~UpdateResponse() {
  // @@protoc_insertion_point(destructor:webcamshooting.UpdateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.players_.~RepeatedPtrField();
}

void UpdateResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:webcamshooting.UpdateResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.players_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .webcamshooting.PlayerUpdateResponse players = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webcamshooting.UpdateResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .webcamshooting.PlayerUpdateResponse players = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webcamshooting.UpdateResponse)
  return target;
}

size_t UpdateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webcamshooting.UpdateResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .webcamshooting.PlayerUpdateResponse players = 1;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->_impl_.players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateResponse::GetClassData() const { return &_class_data_; }


void UpdateResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateResponse*>(&to_msg);
  auto& from = static_cast<const UpdateResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:webcamshooting.UpdateResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateResponse::CopyFrom(const UpdateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webcamshooting.UpdateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateResponse::IsInitialized() const {
  return true;
}

void UpdateResponse::InternalSwap(UpdateResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[12]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace webcamshooting
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::webcamshooting::Vector3*
Arena::CreateMaybeMessage< ::webcamshooting::Vector3 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::Vector3 >(arena);
}
template<> PROTOBUF_NOINLINE ::webcamshooting::Damage*
Arena::CreateMaybeMessage< ::webcamshooting::Damage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::Damage >(arena);
}
template<> PROTOBUF_NOINLINE ::webcamshooting::Player*
Arena::CreateMaybeMessage< ::webcamshooting::Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::Player >(arena);
}
template<> PROTOBUF_NOINLINE ::webcamshooting::ClientUpdate*
Arena::CreateMaybeMessage< ::webcamshooting::ClientUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::ClientUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::webcamshooting::JoinRequest*
Arena::CreateMaybeMessage< ::webcamshooting::JoinRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::JoinRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::webcamshooting::DeadUpdate*
Arena::CreateMaybeMessage< ::webcamshooting::DeadUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::DeadUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::webcamshooting::RespawnRequest*
Arena::CreateMaybeMessage< ::webcamshooting::RespawnRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::RespawnRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::webcamshooting::Request*
Arena::CreateMaybeMessage< ::webcamshooting::Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::Request >(arena);
}
template<> PROTOBUF_NOINLINE ::webcamshooting::Response*
Arena::CreateMaybeMessage< ::webcamshooting::Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::Response >(arena);
}
template<> PROTOBUF_NOINLINE ::webcamshooting::PidResponse*
Arena::CreateMaybeMessage< ::webcamshooting::PidResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::PidResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::webcamshooting::DamageResponse*
Arena::CreateMaybeMessage< ::webcamshooting::DamageResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::DamageResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::webcamshooting::PlayerUpdateResponse*
Arena::CreateMaybeMessage< ::webcamshooting::PlayerUpdateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::PlayerUpdateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::webcamshooting::UpdateResponse*
Arena::CreateMaybeMessage< ::webcamshooting::UpdateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::webcamshooting::UpdateResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
