// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_game_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_game_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_game_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_game_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_game_2eproto;
namespace webcamshooting {
class ClientUpdate;
struct ClientUpdateDefaultTypeInternal;
extern ClientUpdateDefaultTypeInternal _ClientUpdate_default_instance_;
class Damage;
struct DamageDefaultTypeInternal;
extern DamageDefaultTypeInternal _Damage_default_instance_;
class DamageResponse;
struct DamageResponseDefaultTypeInternal;
extern DamageResponseDefaultTypeInternal _DamageResponse_default_instance_;
class DeadUpdate;
struct DeadUpdateDefaultTypeInternal;
extern DeadUpdateDefaultTypeInternal _DeadUpdate_default_instance_;
class JoinRequest;
struct JoinRequestDefaultTypeInternal;
extern JoinRequestDefaultTypeInternal _JoinRequest_default_instance_;
class PidResponse;
struct PidResponseDefaultTypeInternal;
extern PidResponseDefaultTypeInternal _PidResponse_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PlayerUpdateResponse;
struct PlayerUpdateResponseDefaultTypeInternal;
extern PlayerUpdateResponseDefaultTypeInternal _PlayerUpdateResponse_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RespawnRequest;
struct RespawnRequestDefaultTypeInternal;
extern RespawnRequestDefaultTypeInternal _RespawnRequest_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class UpdateResponse;
struct UpdateResponseDefaultTypeInternal;
extern UpdateResponseDefaultTypeInternal _UpdateResponse_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
}  // namespace webcamshooting
PROTOBUF_NAMESPACE_OPEN
template<> ::webcamshooting::ClientUpdate* Arena::CreateMaybeMessage<::webcamshooting::ClientUpdate>(Arena*);
template<> ::webcamshooting::Damage* Arena::CreateMaybeMessage<::webcamshooting::Damage>(Arena*);
template<> ::webcamshooting::DamageResponse* Arena::CreateMaybeMessage<::webcamshooting::DamageResponse>(Arena*);
template<> ::webcamshooting::DeadUpdate* Arena::CreateMaybeMessage<::webcamshooting::DeadUpdate>(Arena*);
template<> ::webcamshooting::JoinRequest* Arena::CreateMaybeMessage<::webcamshooting::JoinRequest>(Arena*);
template<> ::webcamshooting::PidResponse* Arena::CreateMaybeMessage<::webcamshooting::PidResponse>(Arena*);
template<> ::webcamshooting::Player* Arena::CreateMaybeMessage<::webcamshooting::Player>(Arena*);
template<> ::webcamshooting::PlayerUpdateResponse* Arena::CreateMaybeMessage<::webcamshooting::PlayerUpdateResponse>(Arena*);
template<> ::webcamshooting::Request* Arena::CreateMaybeMessage<::webcamshooting::Request>(Arena*);
template<> ::webcamshooting::RespawnRequest* Arena::CreateMaybeMessage<::webcamshooting::RespawnRequest>(Arena*);
template<> ::webcamshooting::Response* Arena::CreateMaybeMessage<::webcamshooting::Response>(Arena*);
template<> ::webcamshooting::UpdateResponse* Arena::CreateMaybeMessage<::webcamshooting::UpdateResponse>(Arena*);
template<> ::webcamshooting::Vector3* Arena::CreateMaybeMessage<::webcamshooting::Vector3>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace webcamshooting {

// ===================================================================

class Vector3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  explicit PROTOBUF_CONSTEXPR Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector3& from) {
    Vector3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:webcamshooting.Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Damage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.Damage) */ {
 public:
  inline Damage() : Damage(nullptr) {}
  ~Damage() override;
  explicit PROTOBUF_CONSTEXPR Damage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Damage(const Damage& from);
  Damage(Damage&& from) noexcept
    : Damage() {
    *this = ::std::move(from);
  }

  inline Damage& operator=(const Damage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Damage& operator=(Damage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Damage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Damage* internal_default_instance() {
    return reinterpret_cast<const Damage*>(
               &_Damage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Damage& a, Damage& b) {
    a.Swap(&b);
  }
  inline void Swap(Damage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Damage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Damage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Damage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Damage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Damage& from) {
    Damage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Damage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.Damage";
  }
  protected:
  explicit Damage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kDamageFieldNumber = 2,
  };
  // string pid = 1;
  void clear_pid();
  const std::string& pid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // float damage = 2;
  void clear_damage();
  float damage() const;
  void set_damage(float value);
  private:
  float _internal_damage() const;
  void _internal_set_damage(float value);
  public:

  // @@protoc_insertion_point(class_scope:webcamshooting.Damage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
    float damage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  explicit PROTOBUF_CONSTEXPR Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Player& from) {
    Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kVelocityFieldNumber = 2,
    kYawFieldNumber = 3,
    kPitchFieldNumber = 4,
  };
  // .webcamshooting.Vector3 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::webcamshooting::Vector3& position() const;
  PROTOBUF_NODISCARD ::webcamshooting::Vector3* release_position();
  ::webcamshooting::Vector3* mutable_position();
  void set_allocated_position(::webcamshooting::Vector3* position);
  private:
  const ::webcamshooting::Vector3& _internal_position() const;
  ::webcamshooting::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::webcamshooting::Vector3* position);
  ::webcamshooting::Vector3* unsafe_arena_release_position();

  // .webcamshooting.Vector3 velocity = 2;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::webcamshooting::Vector3& velocity() const;
  PROTOBUF_NODISCARD ::webcamshooting::Vector3* release_velocity();
  ::webcamshooting::Vector3* mutable_velocity();
  void set_allocated_velocity(::webcamshooting::Vector3* velocity);
  private:
  const ::webcamshooting::Vector3& _internal_velocity() const;
  ::webcamshooting::Vector3* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::webcamshooting::Vector3* velocity);
  ::webcamshooting::Vector3* unsafe_arena_release_velocity();

  // float yaw = 3;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float pitch = 4;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // @@protoc_insertion_point(class_scope:webcamshooting.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::webcamshooting::Vector3* position_;
    ::webcamshooting::Vector3* velocity_;
    float yaw_;
    float pitch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class ClientUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.ClientUpdate) */ {
 public:
  inline ClientUpdate() : ClientUpdate(nullptr) {}
  ~ClientUpdate() override;
  explicit PROTOBUF_CONSTEXPR ClientUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientUpdate(const ClientUpdate& from);
  ClientUpdate(ClientUpdate&& from) noexcept
    : ClientUpdate() {
    *this = ::std::move(from);
  }

  inline ClientUpdate& operator=(const ClientUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientUpdate& operator=(ClientUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientUpdate* internal_default_instance() {
    return reinterpret_cast<const ClientUpdate*>(
               &_ClientUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClientUpdate& a, ClientUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientUpdate& from) {
    ClientUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.ClientUpdate";
  }
  protected:
  explicit ClientUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDamagesFieldNumber = 4,
    kPidFieldNumber = 1,
    kPlayerFieldNumber = 2,
    kFiredFieldNumber = 3,
  };
  // repeated .webcamshooting.Damage damages = 4;
  int damages_size() const;
  private:
  int _internal_damages_size() const;
  public:
  void clear_damages();
  ::webcamshooting::Damage* mutable_damages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::Damage >*
      mutable_damages();
  private:
  const ::webcamshooting::Damage& _internal_damages(int index) const;
  ::webcamshooting::Damage* _internal_add_damages();
  public:
  const ::webcamshooting::Damage& damages(int index) const;
  ::webcamshooting::Damage* add_damages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::Damage >&
      damages() const;

  // string pid = 1;
  void clear_pid();
  const std::string& pid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // .webcamshooting.Player player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::webcamshooting::Player& player() const;
  PROTOBUF_NODISCARD ::webcamshooting::Player* release_player();
  ::webcamshooting::Player* mutable_player();
  void set_allocated_player(::webcamshooting::Player* player);
  private:
  const ::webcamshooting::Player& _internal_player() const;
  ::webcamshooting::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::webcamshooting::Player* player);
  ::webcamshooting::Player* unsafe_arena_release_player();

  // bool fired = 3;
  void clear_fired();
  bool fired() const;
  void set_fired(bool value);
  private:
  bool _internal_fired() const;
  void _internal_set_fired(bool value);
  public:

  // @@protoc_insertion_point(class_scope:webcamshooting.ClientUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::Damage > damages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
    ::webcamshooting::Player* player_;
    bool fired_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class JoinRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.JoinRequest) */ {
 public:
  inline JoinRequest() : JoinRequest(nullptr) {}
  ~JoinRequest() override;
  explicit PROTOBUF_CONSTEXPR JoinRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRequest(const JoinRequest& from);
  JoinRequest(JoinRequest&& from) noexcept
    : JoinRequest() {
    *this = ::std::move(from);
  }

  inline JoinRequest& operator=(const JoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRequest& operator=(JoinRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRequest* internal_default_instance() {
    return reinterpret_cast<const JoinRequest*>(
               &_JoinRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JoinRequest& a, JoinRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinRequest& from) {
    JoinRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.JoinRequest";
  }
  protected:
  explicit JoinRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:webcamshooting.JoinRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class DeadUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.DeadUpdate) */ {
 public:
  inline DeadUpdate() : DeadUpdate(nullptr) {}
  ~DeadUpdate() override;
  explicit PROTOBUF_CONSTEXPR DeadUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeadUpdate(const DeadUpdate& from);
  DeadUpdate(DeadUpdate&& from) noexcept
    : DeadUpdate() {
    *this = ::std::move(from);
  }

  inline DeadUpdate& operator=(const DeadUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeadUpdate& operator=(DeadUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeadUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeadUpdate* internal_default_instance() {
    return reinterpret_cast<const DeadUpdate*>(
               &_DeadUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeadUpdate& a, DeadUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(DeadUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeadUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeadUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeadUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeadUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeadUpdate& from) {
    DeadUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeadUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.DeadUpdate";
  }
  protected:
  explicit DeadUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kKilledByFieldNumber = 2,
  };
  // string pid = 1;
  void clear_pid();
  const std::string& pid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // optional string killed_by = 2;
  bool has_killed_by() const;
  private:
  bool _internal_has_killed_by() const;
  public:
  void clear_killed_by();
  const std::string& killed_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_killed_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_killed_by();
  PROTOBUF_NODISCARD std::string* release_killed_by();
  void set_allocated_killed_by(std::string* killed_by);
  private:
  const std::string& _internal_killed_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_killed_by(const std::string& value);
  std::string* _internal_mutable_killed_by();
  public:

  // @@protoc_insertion_point(class_scope:webcamshooting.DeadUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr killed_by_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class RespawnRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.RespawnRequest) */ {
 public:
  inline RespawnRequest() : RespawnRequest(nullptr) {}
  ~RespawnRequest() override;
  explicit PROTOBUF_CONSTEXPR RespawnRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RespawnRequest(const RespawnRequest& from);
  RespawnRequest(RespawnRequest&& from) noexcept
    : RespawnRequest() {
    *this = ::std::move(from);
  }

  inline RespawnRequest& operator=(const RespawnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RespawnRequest& operator=(RespawnRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RespawnRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RespawnRequest* internal_default_instance() {
    return reinterpret_cast<const RespawnRequest*>(
               &_RespawnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RespawnRequest& a, RespawnRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RespawnRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RespawnRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RespawnRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RespawnRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RespawnRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RespawnRequest& from) {
    RespawnRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RespawnRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.RespawnRequest";
  }
  protected:
  explicit RespawnRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kPositionFieldNumber = 2,
  };
  // string pid = 1;
  void clear_pid();
  const std::string& pid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // .webcamshooting.Vector3 position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::webcamshooting::Vector3& position() const;
  PROTOBUF_NODISCARD ::webcamshooting::Vector3* release_position();
  ::webcamshooting::Vector3* mutable_position();
  void set_allocated_position(::webcamshooting::Vector3* position);
  private:
  const ::webcamshooting::Vector3& _internal_position() const;
  ::webcamshooting::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::webcamshooting::Vector3* position);
  ::webcamshooting::Vector3* unsafe_arena_release_position();

  // @@protoc_insertion_point(class_scope:webcamshooting.RespawnRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
    ::webcamshooting::Vector3* position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum RequestOneofCase {
    kJoinRequest = 1,
    kClientUpdate = 2,
    kDeadUpdate = 3,
    kRespawnRequest = 4,
    REQUEST_ONEOF_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJoinRequestFieldNumber = 1,
    kClientUpdateFieldNumber = 2,
    kDeadUpdateFieldNumber = 3,
    kRespawnRequestFieldNumber = 4,
  };
  // .webcamshooting.JoinRequest join_request = 1;
  bool has_join_request() const;
  private:
  bool _internal_has_join_request() const;
  public:
  void clear_join_request();
  const ::webcamshooting::JoinRequest& join_request() const;
  PROTOBUF_NODISCARD ::webcamshooting::JoinRequest* release_join_request();
  ::webcamshooting::JoinRequest* mutable_join_request();
  void set_allocated_join_request(::webcamshooting::JoinRequest* join_request);
  private:
  const ::webcamshooting::JoinRequest& _internal_join_request() const;
  ::webcamshooting::JoinRequest* _internal_mutable_join_request();
  public:
  void unsafe_arena_set_allocated_join_request(
      ::webcamshooting::JoinRequest* join_request);
  ::webcamshooting::JoinRequest* unsafe_arena_release_join_request();

  // .webcamshooting.ClientUpdate client_update = 2;
  bool has_client_update() const;
  private:
  bool _internal_has_client_update() const;
  public:
  void clear_client_update();
  const ::webcamshooting::ClientUpdate& client_update() const;
  PROTOBUF_NODISCARD ::webcamshooting::ClientUpdate* release_client_update();
  ::webcamshooting::ClientUpdate* mutable_client_update();
  void set_allocated_client_update(::webcamshooting::ClientUpdate* client_update);
  private:
  const ::webcamshooting::ClientUpdate& _internal_client_update() const;
  ::webcamshooting::ClientUpdate* _internal_mutable_client_update();
  public:
  void unsafe_arena_set_allocated_client_update(
      ::webcamshooting::ClientUpdate* client_update);
  ::webcamshooting::ClientUpdate* unsafe_arena_release_client_update();

  // .webcamshooting.DeadUpdate dead_update = 3;
  bool has_dead_update() const;
  private:
  bool _internal_has_dead_update() const;
  public:
  void clear_dead_update();
  const ::webcamshooting::DeadUpdate& dead_update() const;
  PROTOBUF_NODISCARD ::webcamshooting::DeadUpdate* release_dead_update();
  ::webcamshooting::DeadUpdate* mutable_dead_update();
  void set_allocated_dead_update(::webcamshooting::DeadUpdate* dead_update);
  private:
  const ::webcamshooting::DeadUpdate& _internal_dead_update() const;
  ::webcamshooting::DeadUpdate* _internal_mutable_dead_update();
  public:
  void unsafe_arena_set_allocated_dead_update(
      ::webcamshooting::DeadUpdate* dead_update);
  ::webcamshooting::DeadUpdate* unsafe_arena_release_dead_update();

  // .webcamshooting.RespawnRequest respawn_request = 4;
  bool has_respawn_request() const;
  private:
  bool _internal_has_respawn_request() const;
  public:
  void clear_respawn_request();
  const ::webcamshooting::RespawnRequest& respawn_request() const;
  PROTOBUF_NODISCARD ::webcamshooting::RespawnRequest* release_respawn_request();
  ::webcamshooting::RespawnRequest* mutable_respawn_request();
  void set_allocated_respawn_request(::webcamshooting::RespawnRequest* respawn_request);
  private:
  const ::webcamshooting::RespawnRequest& _internal_respawn_request() const;
  ::webcamshooting::RespawnRequest* _internal_mutable_respawn_request();
  public:
  void unsafe_arena_set_allocated_respawn_request(
      ::webcamshooting::RespawnRequest* respawn_request);
  ::webcamshooting::RespawnRequest* unsafe_arena_release_respawn_request();

  void clear_request_oneof();
  RequestOneofCase request_oneof_case() const;
  // @@protoc_insertion_point(class_scope:webcamshooting.Request)
 private:
  class _Internal;
  void set_has_join_request();
  void set_has_client_update();
  void set_has_dead_update();
  void set_has_respawn_request();

  inline bool has_request_oneof() const;
  inline void clear_has_request_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestOneofUnion {
      constexpr RequestOneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::webcamshooting::JoinRequest* join_request_;
      ::webcamshooting::ClientUpdate* client_update_;
      ::webcamshooting::DeadUpdate* dead_update_;
      ::webcamshooting::RespawnRequest* respawn_request_;
    } request_oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseOneofCase {
    kPidResponse = 1,
    kUpdateResponse = 2,
    RESPONSE_ONEOF_NOT_SET = 0,
  };

  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidResponseFieldNumber = 1,
    kUpdateResponseFieldNumber = 2,
  };
  // .webcamshooting.PidResponse pid_response = 1;
  bool has_pid_response() const;
  private:
  bool _internal_has_pid_response() const;
  public:
  void clear_pid_response();
  const ::webcamshooting::PidResponse& pid_response() const;
  PROTOBUF_NODISCARD ::webcamshooting::PidResponse* release_pid_response();
  ::webcamshooting::PidResponse* mutable_pid_response();
  void set_allocated_pid_response(::webcamshooting::PidResponse* pid_response);
  private:
  const ::webcamshooting::PidResponse& _internal_pid_response() const;
  ::webcamshooting::PidResponse* _internal_mutable_pid_response();
  public:
  void unsafe_arena_set_allocated_pid_response(
      ::webcamshooting::PidResponse* pid_response);
  ::webcamshooting::PidResponse* unsafe_arena_release_pid_response();

  // .webcamshooting.UpdateResponse update_response = 2;
  bool has_update_response() const;
  private:
  bool _internal_has_update_response() const;
  public:
  void clear_update_response();
  const ::webcamshooting::UpdateResponse& update_response() const;
  PROTOBUF_NODISCARD ::webcamshooting::UpdateResponse* release_update_response();
  ::webcamshooting::UpdateResponse* mutable_update_response();
  void set_allocated_update_response(::webcamshooting::UpdateResponse* update_response);
  private:
  const ::webcamshooting::UpdateResponse& _internal_update_response() const;
  ::webcamshooting::UpdateResponse* _internal_mutable_update_response();
  public:
  void unsafe_arena_set_allocated_update_response(
      ::webcamshooting::UpdateResponse* update_response);
  ::webcamshooting::UpdateResponse* unsafe_arena_release_update_response();

  void clear_response_oneof();
  ResponseOneofCase response_oneof_case() const;
  // @@protoc_insertion_point(class_scope:webcamshooting.Response)
 private:
  class _Internal;
  void set_has_pid_response();
  void set_has_update_response();

  inline bool has_response_oneof() const;
  inline void clear_has_response_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseOneofUnion {
      constexpr ResponseOneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::webcamshooting::PidResponse* pid_response_;
      ::webcamshooting::UpdateResponse* update_response_;
    } response_oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class PidResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.PidResponse) */ {
 public:
  inline PidResponse() : PidResponse(nullptr) {}
  ~PidResponse() override;
  explicit PROTOBUF_CONSTEXPR PidResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PidResponse(const PidResponse& from);
  PidResponse(PidResponse&& from) noexcept
    : PidResponse() {
    *this = ::std::move(from);
  }

  inline PidResponse& operator=(const PidResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PidResponse& operator=(PidResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PidResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PidResponse* internal_default_instance() {
    return reinterpret_cast<const PidResponse*>(
               &_PidResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PidResponse& a, PidResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PidResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PidResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PidResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PidResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PidResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PidResponse& from) {
    PidResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PidResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.PidResponse";
  }
  protected:
  explicit PidResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
  };
  // string pid = 1;
  void clear_pid();
  const std::string& pid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // @@protoc_insertion_point(class_scope:webcamshooting.PidResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class DamageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.DamageResponse) */ {
 public:
  inline DamageResponse() : DamageResponse(nullptr) {}
  ~DamageResponse() override;
  explicit PROTOBUF_CONSTEXPR DamageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DamageResponse(const DamageResponse& from);
  DamageResponse(DamageResponse&& from) noexcept
    : DamageResponse() {
    *this = ::std::move(from);
  }

  inline DamageResponse& operator=(const DamageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DamageResponse& operator=(DamageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DamageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DamageResponse* internal_default_instance() {
    return reinterpret_cast<const DamageResponse*>(
               &_DamageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DamageResponse& a, DamageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DamageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DamageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DamageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DamageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DamageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DamageResponse& from) {
    DamageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DamageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.DamageResponse";
  }
  protected:
  explicit DamageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kByFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string by = 1;
  void clear_by();
  const std::string& by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_by();
  PROTOBUF_NODISCARD std::string* release_by();
  void set_allocated_by(std::string* by);
  private:
  const std::string& _internal_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_by(const std::string& value);
  std::string* _internal_mutable_by();
  public:

  // float amount = 2;
  void clear_amount();
  float amount() const;
  void set_amount(float value);
  private:
  float _internal_amount() const;
  void _internal_set_amount(float value);
  public:

  // @@protoc_insertion_point(class_scope:webcamshooting.DamageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr by_;
    float amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class PlayerUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.PlayerUpdateResponse) */ {
 public:
  inline PlayerUpdateResponse() : PlayerUpdateResponse(nullptr) {}
  ~PlayerUpdateResponse() override;
  explicit PROTOBUF_CONSTEXPR PlayerUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerUpdateResponse(const PlayerUpdateResponse& from);
  PlayerUpdateResponse(PlayerUpdateResponse&& from) noexcept
    : PlayerUpdateResponse() {
    *this = ::std::move(from);
  }

  inline PlayerUpdateResponse& operator=(const PlayerUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerUpdateResponse& operator=(PlayerUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerUpdateResponse*>(
               &_PlayerUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PlayerUpdateResponse& a, PlayerUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerUpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerUpdateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerUpdateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerUpdateResponse& from) {
    PlayerUpdateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerUpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.PlayerUpdateResponse";
  }
  protected:
  explicit PlayerUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDamagesFieldNumber = 7,
    kPidFieldNumber = 1,
    kPlayerFieldNumber = 2,
    kDeadFieldNumber = 3,
    kFiredFieldNumber = 6,
  };
  // repeated .webcamshooting.DamageResponse damages = 7;
  int damages_size() const;
  private:
  int _internal_damages_size() const;
  public:
  void clear_damages();
  ::webcamshooting::DamageResponse* mutable_damages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::DamageResponse >*
      mutable_damages();
  private:
  const ::webcamshooting::DamageResponse& _internal_damages(int index) const;
  ::webcamshooting::DamageResponse* _internal_add_damages();
  public:
  const ::webcamshooting::DamageResponse& damages(int index) const;
  ::webcamshooting::DamageResponse* add_damages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::DamageResponse >&
      damages() const;

  // string pid = 1;
  void clear_pid();
  const std::string& pid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // .webcamshooting.Player player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::webcamshooting::Player& player() const;
  PROTOBUF_NODISCARD ::webcamshooting::Player* release_player();
  ::webcamshooting::Player* mutable_player();
  void set_allocated_player(::webcamshooting::Player* player);
  private:
  const ::webcamshooting::Player& _internal_player() const;
  ::webcamshooting::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::webcamshooting::Player* player);
  ::webcamshooting::Player* unsafe_arena_release_player();

  // bool dead = 3;
  void clear_dead();
  bool dead() const;
  void set_dead(bool value);
  private:
  bool _internal_dead() const;
  void _internal_set_dead(bool value);
  public:

  // bool fired = 6;
  void clear_fired();
  bool fired() const;
  void set_fired(bool value);
  private:
  bool _internal_fired() const;
  void _internal_set_fired(bool value);
  public:

  // @@protoc_insertion_point(class_scope:webcamshooting.PlayerUpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::DamageResponse > damages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
    ::webcamshooting::Player* player_;
    bool dead_;
    bool fired_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class UpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:webcamshooting.UpdateResponse) */ {
 public:
  inline UpdateResponse() : UpdateResponse(nullptr) {}
  ~UpdateResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateResponse(const UpdateResponse& from);
  UpdateResponse(UpdateResponse&& from) noexcept
    : UpdateResponse() {
    *this = ::std::move(from);
  }

  inline UpdateResponse& operator=(const UpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateResponse& operator=(UpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateResponse*>(
               &_UpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UpdateResponse& a, UpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateResponse& from) {
    UpdateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webcamshooting.UpdateResponse";
  }
  protected:
  explicit UpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .webcamshooting.PlayerUpdateResponse players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::webcamshooting::PlayerUpdateResponse* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::PlayerUpdateResponse >*
      mutable_players();
  private:
  const ::webcamshooting::PlayerUpdateResponse& _internal_players(int index) const;
  ::webcamshooting::PlayerUpdateResponse* _internal_add_players();
  public:
  const ::webcamshooting::PlayerUpdateResponse& players(int index) const;
  ::webcamshooting::PlayerUpdateResponse* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::PlayerUpdateResponse >&
      players() const;

  // @@protoc_insertion_point(class_scope:webcamshooting.UpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::PlayerUpdateResponse > players_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  _impl_.x_ = 0;
}
inline float Vector3::_internal_x() const {
  return _impl_.x_;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Vector3.x)
  return _internal_x();
}
inline void Vector3::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Vector3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:webcamshooting.Vector3.x)
}

// float y = 2;
inline void Vector3::clear_y() {
  _impl_.y_ = 0;
}
inline float Vector3::_internal_y() const {
  return _impl_.y_;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Vector3.y)
  return _internal_y();
}
inline void Vector3::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Vector3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:webcamshooting.Vector3.y)
}

// float z = 3;
inline void Vector3::clear_z() {
  _impl_.z_ = 0;
}
inline float Vector3::_internal_z() const {
  return _impl_.z_;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Vector3.z)
  return _internal_z();
}
inline void Vector3::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Vector3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:webcamshooting.Vector3.z)
}

// -------------------------------------------------------------------

// Damage

// string pid = 1;
inline void Damage::clear_pid() {
  _impl_.pid_.ClearToEmpty();
}
inline const std::string& Damage::pid() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Damage.pid)
  return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Damage::set_pid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:webcamshooting.Damage.pid)
}
inline std::string* Damage::mutable_pid() {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:webcamshooting.Damage.pid)
  return _s;
}
inline const std::string& Damage::_internal_pid() const {
  return _impl_.pid_.Get();
}
inline void Damage::_internal_set_pid(const std::string& value) {
  
  _impl_.pid_.Set(value, GetArenaForAllocation());
}
inline std::string* Damage::_internal_mutable_pid() {
  
  return _impl_.pid_.Mutable(GetArenaForAllocation());
}
inline std::string* Damage::release_pid() {
  // @@protoc_insertion_point(field_release:webcamshooting.Damage.pid)
  return _impl_.pid_.Release();
}
inline void Damage::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  _impl_.pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pid_.IsDefault()) {
    _impl_.pid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.Damage.pid)
}

// float damage = 2;
inline void Damage::clear_damage() {
  _impl_.damage_ = 0;
}
inline float Damage::_internal_damage() const {
  return _impl_.damage_;
}
inline float Damage::damage() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Damage.damage)
  return _internal_damage();
}
inline void Damage::_internal_set_damage(float value) {
  
  _impl_.damage_ = value;
}
inline void Damage::set_damage(float value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:webcamshooting.Damage.damage)
}

// -------------------------------------------------------------------

// Player

// .webcamshooting.Vector3 position = 1;
inline bool Player::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool Player::has_position() const {
  return _internal_has_position();
}
inline void Player::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::webcamshooting::Vector3& Player::_internal_position() const {
  const ::webcamshooting::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::webcamshooting::Vector3&>(
      ::webcamshooting::_Vector3_default_instance_);
}
inline const ::webcamshooting::Vector3& Player::position() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Player.position)
  return _internal_position();
}
inline void Player::unsafe_arena_set_allocated_position(
    ::webcamshooting::Vector3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webcamshooting.Player.position)
}
inline ::webcamshooting::Vector3* Player::release_position() {
  
  ::webcamshooting::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::webcamshooting::Vector3* Player::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:webcamshooting.Player.position)
  
  ::webcamshooting::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::webcamshooting::Vector3* Player::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::webcamshooting::Vector3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::webcamshooting::Vector3* Player::mutable_position() {
  ::webcamshooting::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:webcamshooting.Player.position)
  return _msg;
}
inline void Player::set_allocated_position(::webcamshooting::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.Player.position)
}

// .webcamshooting.Vector3 velocity = 2;
inline bool Player::_internal_has_velocity() const {
  return this != internal_default_instance() && _impl_.velocity_ != nullptr;
}
inline bool Player::has_velocity() const {
  return _internal_has_velocity();
}
inline void Player::clear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr) {
    delete _impl_.velocity_;
  }
  _impl_.velocity_ = nullptr;
}
inline const ::webcamshooting::Vector3& Player::_internal_velocity() const {
  const ::webcamshooting::Vector3* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::webcamshooting::Vector3&>(
      ::webcamshooting::_Vector3_default_instance_);
}
inline const ::webcamshooting::Vector3& Player::velocity() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Player.velocity)
  return _internal_velocity();
}
inline void Player::unsafe_arena_set_allocated_velocity(
    ::webcamshooting::Vector3* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webcamshooting.Player.velocity)
}
inline ::webcamshooting::Vector3* Player::release_velocity() {
  
  ::webcamshooting::Vector3* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::webcamshooting::Vector3* Player::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:webcamshooting.Player.velocity)
  
  ::webcamshooting::Vector3* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::webcamshooting::Vector3* Player::_internal_mutable_velocity() {
  
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::webcamshooting::Vector3>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::webcamshooting::Vector3* Player::mutable_velocity() {
  ::webcamshooting::Vector3* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:webcamshooting.Player.velocity)
  return _msg;
}
inline void Player::set_allocated_velocity(::webcamshooting::Vector3* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.Player.velocity)
}

// float yaw = 3;
inline void Player::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float Player::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float Player::yaw() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Player.yaw)
  return _internal_yaw();
}
inline void Player::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void Player::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:webcamshooting.Player.yaw)
}

// float pitch = 4;
inline void Player::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float Player::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float Player::pitch() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Player.pitch)
  return _internal_pitch();
}
inline void Player::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void Player::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:webcamshooting.Player.pitch)
}

// -------------------------------------------------------------------

// ClientUpdate

// string pid = 1;
inline void ClientUpdate::clear_pid() {
  _impl_.pid_.ClearToEmpty();
}
inline const std::string& ClientUpdate::pid() const {
  // @@protoc_insertion_point(field_get:webcamshooting.ClientUpdate.pid)
  return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientUpdate::set_pid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:webcamshooting.ClientUpdate.pid)
}
inline std::string* ClientUpdate::mutable_pid() {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:webcamshooting.ClientUpdate.pid)
  return _s;
}
inline const std::string& ClientUpdate::_internal_pid() const {
  return _impl_.pid_.Get();
}
inline void ClientUpdate::_internal_set_pid(const std::string& value) {
  
  _impl_.pid_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientUpdate::_internal_mutable_pid() {
  
  return _impl_.pid_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientUpdate::release_pid() {
  // @@protoc_insertion_point(field_release:webcamshooting.ClientUpdate.pid)
  return _impl_.pid_.Release();
}
inline void ClientUpdate::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  _impl_.pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pid_.IsDefault()) {
    _impl_.pid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.ClientUpdate.pid)
}

// .webcamshooting.Player player = 2;
inline bool ClientUpdate::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool ClientUpdate::has_player() const {
  return _internal_has_player();
}
inline void ClientUpdate::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::webcamshooting::Player& ClientUpdate::_internal_player() const {
  const ::webcamshooting::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::webcamshooting::Player&>(
      ::webcamshooting::_Player_default_instance_);
}
inline const ::webcamshooting::Player& ClientUpdate::player() const {
  // @@protoc_insertion_point(field_get:webcamshooting.ClientUpdate.player)
  return _internal_player();
}
inline void ClientUpdate::unsafe_arena_set_allocated_player(
    ::webcamshooting::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webcamshooting.ClientUpdate.player)
}
inline ::webcamshooting::Player* ClientUpdate::release_player() {
  
  ::webcamshooting::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::webcamshooting::Player* ClientUpdate::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:webcamshooting.ClientUpdate.player)
  
  ::webcamshooting::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::webcamshooting::Player* ClientUpdate::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::webcamshooting::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::webcamshooting::Player* ClientUpdate::mutable_player() {
  ::webcamshooting::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:webcamshooting.ClientUpdate.player)
  return _msg;
}
inline void ClientUpdate::set_allocated_player(::webcamshooting::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.ClientUpdate.player)
}

// bool fired = 3;
inline void ClientUpdate::clear_fired() {
  _impl_.fired_ = false;
}
inline bool ClientUpdate::_internal_fired() const {
  return _impl_.fired_;
}
inline bool ClientUpdate::fired() const {
  // @@protoc_insertion_point(field_get:webcamshooting.ClientUpdate.fired)
  return _internal_fired();
}
inline void ClientUpdate::_internal_set_fired(bool value) {
  
  _impl_.fired_ = value;
}
inline void ClientUpdate::set_fired(bool value) {
  _internal_set_fired(value);
  // @@protoc_insertion_point(field_set:webcamshooting.ClientUpdate.fired)
}

// repeated .webcamshooting.Damage damages = 4;
inline int ClientUpdate::_internal_damages_size() const {
  return _impl_.damages_.size();
}
inline int ClientUpdate::damages_size() const {
  return _internal_damages_size();
}
inline void ClientUpdate::clear_damages() {
  _impl_.damages_.Clear();
}
inline ::webcamshooting::Damage* ClientUpdate::mutable_damages(int index) {
  // @@protoc_insertion_point(field_mutable:webcamshooting.ClientUpdate.damages)
  return _impl_.damages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::Damage >*
ClientUpdate::mutable_damages() {
  // @@protoc_insertion_point(field_mutable_list:webcamshooting.ClientUpdate.damages)
  return &_impl_.damages_;
}
inline const ::webcamshooting::Damage& ClientUpdate::_internal_damages(int index) const {
  return _impl_.damages_.Get(index);
}
inline const ::webcamshooting::Damage& ClientUpdate::damages(int index) const {
  // @@protoc_insertion_point(field_get:webcamshooting.ClientUpdate.damages)
  return _internal_damages(index);
}
inline ::webcamshooting::Damage* ClientUpdate::_internal_add_damages() {
  return _impl_.damages_.Add();
}
inline ::webcamshooting::Damage* ClientUpdate::add_damages() {
  ::webcamshooting::Damage* _add = _internal_add_damages();
  // @@protoc_insertion_point(field_add:webcamshooting.ClientUpdate.damages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::Damage >&
ClientUpdate::damages() const {
  // @@protoc_insertion_point(field_list:webcamshooting.ClientUpdate.damages)
  return _impl_.damages_;
}

// -------------------------------------------------------------------

// JoinRequest

// string name = 1;
inline void JoinRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& JoinRequest::name() const {
  // @@protoc_insertion_point(field_get:webcamshooting.JoinRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:webcamshooting.JoinRequest.name)
}
inline std::string* JoinRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:webcamshooting.JoinRequest.name)
  return _s;
}
inline const std::string& JoinRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void JoinRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinRequest::release_name() {
  // @@protoc_insertion_point(field_release:webcamshooting.JoinRequest.name)
  return _impl_.name_.Release();
}
inline void JoinRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.JoinRequest.name)
}

// -------------------------------------------------------------------

// DeadUpdate

// string pid = 1;
inline void DeadUpdate::clear_pid() {
  _impl_.pid_.ClearToEmpty();
}
inline const std::string& DeadUpdate::pid() const {
  // @@protoc_insertion_point(field_get:webcamshooting.DeadUpdate.pid)
  return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeadUpdate::set_pid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:webcamshooting.DeadUpdate.pid)
}
inline std::string* DeadUpdate::mutable_pid() {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:webcamshooting.DeadUpdate.pid)
  return _s;
}
inline const std::string& DeadUpdate::_internal_pid() const {
  return _impl_.pid_.Get();
}
inline void DeadUpdate::_internal_set_pid(const std::string& value) {
  
  _impl_.pid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeadUpdate::_internal_mutable_pid() {
  
  return _impl_.pid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeadUpdate::release_pid() {
  // @@protoc_insertion_point(field_release:webcamshooting.DeadUpdate.pid)
  return _impl_.pid_.Release();
}
inline void DeadUpdate::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  _impl_.pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pid_.IsDefault()) {
    _impl_.pid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.DeadUpdate.pid)
}

// optional string killed_by = 2;
inline bool DeadUpdate::_internal_has_killed_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeadUpdate::has_killed_by() const {
  return _internal_has_killed_by();
}
inline void DeadUpdate::clear_killed_by() {
  _impl_.killed_by_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeadUpdate::killed_by() const {
  // @@protoc_insertion_point(field_get:webcamshooting.DeadUpdate.killed_by)
  return _internal_killed_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeadUpdate::set_killed_by(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.killed_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:webcamshooting.DeadUpdate.killed_by)
}
inline std::string* DeadUpdate::mutable_killed_by() {
  std::string* _s = _internal_mutable_killed_by();
  // @@protoc_insertion_point(field_mutable:webcamshooting.DeadUpdate.killed_by)
  return _s;
}
inline const std::string& DeadUpdate::_internal_killed_by() const {
  return _impl_.killed_by_.Get();
}
inline void DeadUpdate::_internal_set_killed_by(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.killed_by_.Set(value, GetArenaForAllocation());
}
inline std::string* DeadUpdate::_internal_mutable_killed_by() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.killed_by_.Mutable(GetArenaForAllocation());
}
inline std::string* DeadUpdate::release_killed_by() {
  // @@protoc_insertion_point(field_release:webcamshooting.DeadUpdate.killed_by)
  if (!_internal_has_killed_by()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.killed_by_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.killed_by_.IsDefault()) {
    _impl_.killed_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeadUpdate::set_allocated_killed_by(std::string* killed_by) {
  if (killed_by != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.killed_by_.SetAllocated(killed_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.killed_by_.IsDefault()) {
    _impl_.killed_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.DeadUpdate.killed_by)
}

// -------------------------------------------------------------------

// RespawnRequest

// string pid = 1;
inline void RespawnRequest::clear_pid() {
  _impl_.pid_.ClearToEmpty();
}
inline const std::string& RespawnRequest::pid() const {
  // @@protoc_insertion_point(field_get:webcamshooting.RespawnRequest.pid)
  return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RespawnRequest::set_pid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:webcamshooting.RespawnRequest.pid)
}
inline std::string* RespawnRequest::mutable_pid() {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:webcamshooting.RespawnRequest.pid)
  return _s;
}
inline const std::string& RespawnRequest::_internal_pid() const {
  return _impl_.pid_.Get();
}
inline void RespawnRequest::_internal_set_pid(const std::string& value) {
  
  _impl_.pid_.Set(value, GetArenaForAllocation());
}
inline std::string* RespawnRequest::_internal_mutable_pid() {
  
  return _impl_.pid_.Mutable(GetArenaForAllocation());
}
inline std::string* RespawnRequest::release_pid() {
  // @@protoc_insertion_point(field_release:webcamshooting.RespawnRequest.pid)
  return _impl_.pid_.Release();
}
inline void RespawnRequest::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  _impl_.pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pid_.IsDefault()) {
    _impl_.pid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.RespawnRequest.pid)
}

// .webcamshooting.Vector3 position = 2;
inline bool RespawnRequest::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool RespawnRequest::has_position() const {
  return _internal_has_position();
}
inline void RespawnRequest::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::webcamshooting::Vector3& RespawnRequest::_internal_position() const {
  const ::webcamshooting::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::webcamshooting::Vector3&>(
      ::webcamshooting::_Vector3_default_instance_);
}
inline const ::webcamshooting::Vector3& RespawnRequest::position() const {
  // @@protoc_insertion_point(field_get:webcamshooting.RespawnRequest.position)
  return _internal_position();
}
inline void RespawnRequest::unsafe_arena_set_allocated_position(
    ::webcamshooting::Vector3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webcamshooting.RespawnRequest.position)
}
inline ::webcamshooting::Vector3* RespawnRequest::release_position() {
  
  ::webcamshooting::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::webcamshooting::Vector3* RespawnRequest::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:webcamshooting.RespawnRequest.position)
  
  ::webcamshooting::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::webcamshooting::Vector3* RespawnRequest::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::webcamshooting::Vector3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::webcamshooting::Vector3* RespawnRequest::mutable_position() {
  ::webcamshooting::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:webcamshooting.RespawnRequest.position)
  return _msg;
}
inline void RespawnRequest::set_allocated_position(::webcamshooting::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.RespawnRequest.position)
}

// -------------------------------------------------------------------

// Request

// .webcamshooting.JoinRequest join_request = 1;
inline bool Request::_internal_has_join_request() const {
  return request_oneof_case() == kJoinRequest;
}
inline bool Request::has_join_request() const {
  return _internal_has_join_request();
}
inline void Request::set_has_join_request() {
  _impl_._oneof_case_[0] = kJoinRequest;
}
inline void Request::clear_join_request() {
  if (_internal_has_join_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_oneof_.join_request_;
    }
    clear_has_request_oneof();
  }
}
inline ::webcamshooting::JoinRequest* Request::release_join_request() {
  // @@protoc_insertion_point(field_release:webcamshooting.Request.join_request)
  if (_internal_has_join_request()) {
    clear_has_request_oneof();
    ::webcamshooting::JoinRequest* temp = _impl_.request_oneof_.join_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_oneof_.join_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webcamshooting::JoinRequest& Request::_internal_join_request() const {
  return _internal_has_join_request()
      ? *_impl_.request_oneof_.join_request_
      : reinterpret_cast< ::webcamshooting::JoinRequest&>(::webcamshooting::_JoinRequest_default_instance_);
}
inline const ::webcamshooting::JoinRequest& Request::join_request() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Request.join_request)
  return _internal_join_request();
}
inline ::webcamshooting::JoinRequest* Request::unsafe_arena_release_join_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webcamshooting.Request.join_request)
  if (_internal_has_join_request()) {
    clear_has_request_oneof();
    ::webcamshooting::JoinRequest* temp = _impl_.request_oneof_.join_request_;
    _impl_.request_oneof_.join_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_join_request(::webcamshooting::JoinRequest* join_request) {
  clear_request_oneof();
  if (join_request) {
    set_has_join_request();
    _impl_.request_oneof_.join_request_ = join_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webcamshooting.Request.join_request)
}
inline ::webcamshooting::JoinRequest* Request::_internal_mutable_join_request() {
  if (!_internal_has_join_request()) {
    clear_request_oneof();
    set_has_join_request();
    _impl_.request_oneof_.join_request_ = CreateMaybeMessage< ::webcamshooting::JoinRequest >(GetArenaForAllocation());
  }
  return _impl_.request_oneof_.join_request_;
}
inline ::webcamshooting::JoinRequest* Request::mutable_join_request() {
  ::webcamshooting::JoinRequest* _msg = _internal_mutable_join_request();
  // @@protoc_insertion_point(field_mutable:webcamshooting.Request.join_request)
  return _msg;
}

// .webcamshooting.ClientUpdate client_update = 2;
inline bool Request::_internal_has_client_update() const {
  return request_oneof_case() == kClientUpdate;
}
inline bool Request::has_client_update() const {
  return _internal_has_client_update();
}
inline void Request::set_has_client_update() {
  _impl_._oneof_case_[0] = kClientUpdate;
}
inline void Request::clear_client_update() {
  if (_internal_has_client_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_oneof_.client_update_;
    }
    clear_has_request_oneof();
  }
}
inline ::webcamshooting::ClientUpdate* Request::release_client_update() {
  // @@protoc_insertion_point(field_release:webcamshooting.Request.client_update)
  if (_internal_has_client_update()) {
    clear_has_request_oneof();
    ::webcamshooting::ClientUpdate* temp = _impl_.request_oneof_.client_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_oneof_.client_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webcamshooting::ClientUpdate& Request::_internal_client_update() const {
  return _internal_has_client_update()
      ? *_impl_.request_oneof_.client_update_
      : reinterpret_cast< ::webcamshooting::ClientUpdate&>(::webcamshooting::_ClientUpdate_default_instance_);
}
inline const ::webcamshooting::ClientUpdate& Request::client_update() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Request.client_update)
  return _internal_client_update();
}
inline ::webcamshooting::ClientUpdate* Request::unsafe_arena_release_client_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webcamshooting.Request.client_update)
  if (_internal_has_client_update()) {
    clear_has_request_oneof();
    ::webcamshooting::ClientUpdate* temp = _impl_.request_oneof_.client_update_;
    _impl_.request_oneof_.client_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_client_update(::webcamshooting::ClientUpdate* client_update) {
  clear_request_oneof();
  if (client_update) {
    set_has_client_update();
    _impl_.request_oneof_.client_update_ = client_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webcamshooting.Request.client_update)
}
inline ::webcamshooting::ClientUpdate* Request::_internal_mutable_client_update() {
  if (!_internal_has_client_update()) {
    clear_request_oneof();
    set_has_client_update();
    _impl_.request_oneof_.client_update_ = CreateMaybeMessage< ::webcamshooting::ClientUpdate >(GetArenaForAllocation());
  }
  return _impl_.request_oneof_.client_update_;
}
inline ::webcamshooting::ClientUpdate* Request::mutable_client_update() {
  ::webcamshooting::ClientUpdate* _msg = _internal_mutable_client_update();
  // @@protoc_insertion_point(field_mutable:webcamshooting.Request.client_update)
  return _msg;
}

// .webcamshooting.DeadUpdate dead_update = 3;
inline bool Request::_internal_has_dead_update() const {
  return request_oneof_case() == kDeadUpdate;
}
inline bool Request::has_dead_update() const {
  return _internal_has_dead_update();
}
inline void Request::set_has_dead_update() {
  _impl_._oneof_case_[0] = kDeadUpdate;
}
inline void Request::clear_dead_update() {
  if (_internal_has_dead_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_oneof_.dead_update_;
    }
    clear_has_request_oneof();
  }
}
inline ::webcamshooting::DeadUpdate* Request::release_dead_update() {
  // @@protoc_insertion_point(field_release:webcamshooting.Request.dead_update)
  if (_internal_has_dead_update()) {
    clear_has_request_oneof();
    ::webcamshooting::DeadUpdate* temp = _impl_.request_oneof_.dead_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_oneof_.dead_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webcamshooting::DeadUpdate& Request::_internal_dead_update() const {
  return _internal_has_dead_update()
      ? *_impl_.request_oneof_.dead_update_
      : reinterpret_cast< ::webcamshooting::DeadUpdate&>(::webcamshooting::_DeadUpdate_default_instance_);
}
inline const ::webcamshooting::DeadUpdate& Request::dead_update() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Request.dead_update)
  return _internal_dead_update();
}
inline ::webcamshooting::DeadUpdate* Request::unsafe_arena_release_dead_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webcamshooting.Request.dead_update)
  if (_internal_has_dead_update()) {
    clear_has_request_oneof();
    ::webcamshooting::DeadUpdate* temp = _impl_.request_oneof_.dead_update_;
    _impl_.request_oneof_.dead_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_dead_update(::webcamshooting::DeadUpdate* dead_update) {
  clear_request_oneof();
  if (dead_update) {
    set_has_dead_update();
    _impl_.request_oneof_.dead_update_ = dead_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webcamshooting.Request.dead_update)
}
inline ::webcamshooting::DeadUpdate* Request::_internal_mutable_dead_update() {
  if (!_internal_has_dead_update()) {
    clear_request_oneof();
    set_has_dead_update();
    _impl_.request_oneof_.dead_update_ = CreateMaybeMessage< ::webcamshooting::DeadUpdate >(GetArenaForAllocation());
  }
  return _impl_.request_oneof_.dead_update_;
}
inline ::webcamshooting::DeadUpdate* Request::mutable_dead_update() {
  ::webcamshooting::DeadUpdate* _msg = _internal_mutable_dead_update();
  // @@protoc_insertion_point(field_mutable:webcamshooting.Request.dead_update)
  return _msg;
}

// .webcamshooting.RespawnRequest respawn_request = 4;
inline bool Request::_internal_has_respawn_request() const {
  return request_oneof_case() == kRespawnRequest;
}
inline bool Request::has_respawn_request() const {
  return _internal_has_respawn_request();
}
inline void Request::set_has_respawn_request() {
  _impl_._oneof_case_[0] = kRespawnRequest;
}
inline void Request::clear_respawn_request() {
  if (_internal_has_respawn_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_oneof_.respawn_request_;
    }
    clear_has_request_oneof();
  }
}
inline ::webcamshooting::RespawnRequest* Request::release_respawn_request() {
  // @@protoc_insertion_point(field_release:webcamshooting.Request.respawn_request)
  if (_internal_has_respawn_request()) {
    clear_has_request_oneof();
    ::webcamshooting::RespawnRequest* temp = _impl_.request_oneof_.respawn_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_oneof_.respawn_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webcamshooting::RespawnRequest& Request::_internal_respawn_request() const {
  return _internal_has_respawn_request()
      ? *_impl_.request_oneof_.respawn_request_
      : reinterpret_cast< ::webcamshooting::RespawnRequest&>(::webcamshooting::_RespawnRequest_default_instance_);
}
inline const ::webcamshooting::RespawnRequest& Request::respawn_request() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Request.respawn_request)
  return _internal_respawn_request();
}
inline ::webcamshooting::RespawnRequest* Request::unsafe_arena_release_respawn_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webcamshooting.Request.respawn_request)
  if (_internal_has_respawn_request()) {
    clear_has_request_oneof();
    ::webcamshooting::RespawnRequest* temp = _impl_.request_oneof_.respawn_request_;
    _impl_.request_oneof_.respawn_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_respawn_request(::webcamshooting::RespawnRequest* respawn_request) {
  clear_request_oneof();
  if (respawn_request) {
    set_has_respawn_request();
    _impl_.request_oneof_.respawn_request_ = respawn_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webcamshooting.Request.respawn_request)
}
inline ::webcamshooting::RespawnRequest* Request::_internal_mutable_respawn_request() {
  if (!_internal_has_respawn_request()) {
    clear_request_oneof();
    set_has_respawn_request();
    _impl_.request_oneof_.respawn_request_ = CreateMaybeMessage< ::webcamshooting::RespawnRequest >(GetArenaForAllocation());
  }
  return _impl_.request_oneof_.respawn_request_;
}
inline ::webcamshooting::RespawnRequest* Request::mutable_respawn_request() {
  ::webcamshooting::RespawnRequest* _msg = _internal_mutable_respawn_request();
  // @@protoc_insertion_point(field_mutable:webcamshooting.Request.respawn_request)
  return _msg;
}

inline bool Request::has_request_oneof() const {
  return request_oneof_case() != REQUEST_ONEOF_NOT_SET;
}
inline void Request::clear_has_request_oneof() {
  _impl_._oneof_case_[0] = REQUEST_ONEOF_NOT_SET;
}
inline Request::RequestOneofCase Request::request_oneof_case() const {
  return Request::RequestOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// .webcamshooting.PidResponse pid_response = 1;
inline bool Response::_internal_has_pid_response() const {
  return response_oneof_case() == kPidResponse;
}
inline bool Response::has_pid_response() const {
  return _internal_has_pid_response();
}
inline void Response::set_has_pid_response() {
  _impl_._oneof_case_[0] = kPidResponse;
}
inline void Response::clear_pid_response() {
  if (_internal_has_pid_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_oneof_.pid_response_;
    }
    clear_has_response_oneof();
  }
}
inline ::webcamshooting::PidResponse* Response::release_pid_response() {
  // @@protoc_insertion_point(field_release:webcamshooting.Response.pid_response)
  if (_internal_has_pid_response()) {
    clear_has_response_oneof();
    ::webcamshooting::PidResponse* temp = _impl_.response_oneof_.pid_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_oneof_.pid_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webcamshooting::PidResponse& Response::_internal_pid_response() const {
  return _internal_has_pid_response()
      ? *_impl_.response_oneof_.pid_response_
      : reinterpret_cast< ::webcamshooting::PidResponse&>(::webcamshooting::_PidResponse_default_instance_);
}
inline const ::webcamshooting::PidResponse& Response::pid_response() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Response.pid_response)
  return _internal_pid_response();
}
inline ::webcamshooting::PidResponse* Response::unsafe_arena_release_pid_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webcamshooting.Response.pid_response)
  if (_internal_has_pid_response()) {
    clear_has_response_oneof();
    ::webcamshooting::PidResponse* temp = _impl_.response_oneof_.pid_response_;
    _impl_.response_oneof_.pid_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_pid_response(::webcamshooting::PidResponse* pid_response) {
  clear_response_oneof();
  if (pid_response) {
    set_has_pid_response();
    _impl_.response_oneof_.pid_response_ = pid_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webcamshooting.Response.pid_response)
}
inline ::webcamshooting::PidResponse* Response::_internal_mutable_pid_response() {
  if (!_internal_has_pid_response()) {
    clear_response_oneof();
    set_has_pid_response();
    _impl_.response_oneof_.pid_response_ = CreateMaybeMessage< ::webcamshooting::PidResponse >(GetArenaForAllocation());
  }
  return _impl_.response_oneof_.pid_response_;
}
inline ::webcamshooting::PidResponse* Response::mutable_pid_response() {
  ::webcamshooting::PidResponse* _msg = _internal_mutable_pid_response();
  // @@protoc_insertion_point(field_mutable:webcamshooting.Response.pid_response)
  return _msg;
}

// .webcamshooting.UpdateResponse update_response = 2;
inline bool Response::_internal_has_update_response() const {
  return response_oneof_case() == kUpdateResponse;
}
inline bool Response::has_update_response() const {
  return _internal_has_update_response();
}
inline void Response::set_has_update_response() {
  _impl_._oneof_case_[0] = kUpdateResponse;
}
inline void Response::clear_update_response() {
  if (_internal_has_update_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_oneof_.update_response_;
    }
    clear_has_response_oneof();
  }
}
inline ::webcamshooting::UpdateResponse* Response::release_update_response() {
  // @@protoc_insertion_point(field_release:webcamshooting.Response.update_response)
  if (_internal_has_update_response()) {
    clear_has_response_oneof();
    ::webcamshooting::UpdateResponse* temp = _impl_.response_oneof_.update_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_oneof_.update_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webcamshooting::UpdateResponse& Response::_internal_update_response() const {
  return _internal_has_update_response()
      ? *_impl_.response_oneof_.update_response_
      : reinterpret_cast< ::webcamshooting::UpdateResponse&>(::webcamshooting::_UpdateResponse_default_instance_);
}
inline const ::webcamshooting::UpdateResponse& Response::update_response() const {
  // @@protoc_insertion_point(field_get:webcamshooting.Response.update_response)
  return _internal_update_response();
}
inline ::webcamshooting::UpdateResponse* Response::unsafe_arena_release_update_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webcamshooting.Response.update_response)
  if (_internal_has_update_response()) {
    clear_has_response_oneof();
    ::webcamshooting::UpdateResponse* temp = _impl_.response_oneof_.update_response_;
    _impl_.response_oneof_.update_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_update_response(::webcamshooting::UpdateResponse* update_response) {
  clear_response_oneof();
  if (update_response) {
    set_has_update_response();
    _impl_.response_oneof_.update_response_ = update_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webcamshooting.Response.update_response)
}
inline ::webcamshooting::UpdateResponse* Response::_internal_mutable_update_response() {
  if (!_internal_has_update_response()) {
    clear_response_oneof();
    set_has_update_response();
    _impl_.response_oneof_.update_response_ = CreateMaybeMessage< ::webcamshooting::UpdateResponse >(GetArenaForAllocation());
  }
  return _impl_.response_oneof_.update_response_;
}
inline ::webcamshooting::UpdateResponse* Response::mutable_update_response() {
  ::webcamshooting::UpdateResponse* _msg = _internal_mutable_update_response();
  // @@protoc_insertion_point(field_mutable:webcamshooting.Response.update_response)
  return _msg;
}

inline bool Response::has_response_oneof() const {
  return response_oneof_case() != RESPONSE_ONEOF_NOT_SET;
}
inline void Response::clear_has_response_oneof() {
  _impl_._oneof_case_[0] = RESPONSE_ONEOF_NOT_SET;
}
inline Response::ResponseOneofCase Response::response_oneof_case() const {
  return Response::ResponseOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PidResponse

// string pid = 1;
inline void PidResponse::clear_pid() {
  _impl_.pid_.ClearToEmpty();
}
inline const std::string& PidResponse::pid() const {
  // @@protoc_insertion_point(field_get:webcamshooting.PidResponse.pid)
  return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PidResponse::set_pid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:webcamshooting.PidResponse.pid)
}
inline std::string* PidResponse::mutable_pid() {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:webcamshooting.PidResponse.pid)
  return _s;
}
inline const std::string& PidResponse::_internal_pid() const {
  return _impl_.pid_.Get();
}
inline void PidResponse::_internal_set_pid(const std::string& value) {
  
  _impl_.pid_.Set(value, GetArenaForAllocation());
}
inline std::string* PidResponse::_internal_mutable_pid() {
  
  return _impl_.pid_.Mutable(GetArenaForAllocation());
}
inline std::string* PidResponse::release_pid() {
  // @@protoc_insertion_point(field_release:webcamshooting.PidResponse.pid)
  return _impl_.pid_.Release();
}
inline void PidResponse::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  _impl_.pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pid_.IsDefault()) {
    _impl_.pid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.PidResponse.pid)
}

// -------------------------------------------------------------------

// DamageResponse

// string by = 1;
inline void DamageResponse::clear_by() {
  _impl_.by_.ClearToEmpty();
}
inline const std::string& DamageResponse::by() const {
  // @@protoc_insertion_point(field_get:webcamshooting.DamageResponse.by)
  return _internal_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DamageResponse::set_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:webcamshooting.DamageResponse.by)
}
inline std::string* DamageResponse::mutable_by() {
  std::string* _s = _internal_mutable_by();
  // @@protoc_insertion_point(field_mutable:webcamshooting.DamageResponse.by)
  return _s;
}
inline const std::string& DamageResponse::_internal_by() const {
  return _impl_.by_.Get();
}
inline void DamageResponse::_internal_set_by(const std::string& value) {
  
  _impl_.by_.Set(value, GetArenaForAllocation());
}
inline std::string* DamageResponse::_internal_mutable_by() {
  
  return _impl_.by_.Mutable(GetArenaForAllocation());
}
inline std::string* DamageResponse::release_by() {
  // @@protoc_insertion_point(field_release:webcamshooting.DamageResponse.by)
  return _impl_.by_.Release();
}
inline void DamageResponse::set_allocated_by(std::string* by) {
  if (by != nullptr) {
    
  } else {
    
  }
  _impl_.by_.SetAllocated(by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.by_.IsDefault()) {
    _impl_.by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.DamageResponse.by)
}

// float amount = 2;
inline void DamageResponse::clear_amount() {
  _impl_.amount_ = 0;
}
inline float DamageResponse::_internal_amount() const {
  return _impl_.amount_;
}
inline float DamageResponse::amount() const {
  // @@protoc_insertion_point(field_get:webcamshooting.DamageResponse.amount)
  return _internal_amount();
}
inline void DamageResponse::_internal_set_amount(float value) {
  
  _impl_.amount_ = value;
}
inline void DamageResponse::set_amount(float value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:webcamshooting.DamageResponse.amount)
}

// -------------------------------------------------------------------

// PlayerUpdateResponse

// string pid = 1;
inline void PlayerUpdateResponse::clear_pid() {
  _impl_.pid_.ClearToEmpty();
}
inline const std::string& PlayerUpdateResponse::pid() const {
  // @@protoc_insertion_point(field_get:webcamshooting.PlayerUpdateResponse.pid)
  return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerUpdateResponse::set_pid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:webcamshooting.PlayerUpdateResponse.pid)
}
inline std::string* PlayerUpdateResponse::mutable_pid() {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:webcamshooting.PlayerUpdateResponse.pid)
  return _s;
}
inline const std::string& PlayerUpdateResponse::_internal_pid() const {
  return _impl_.pid_.Get();
}
inline void PlayerUpdateResponse::_internal_set_pid(const std::string& value) {
  
  _impl_.pid_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerUpdateResponse::_internal_mutable_pid() {
  
  return _impl_.pid_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerUpdateResponse::release_pid() {
  // @@protoc_insertion_point(field_release:webcamshooting.PlayerUpdateResponse.pid)
  return _impl_.pid_.Release();
}
inline void PlayerUpdateResponse::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  _impl_.pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pid_.IsDefault()) {
    _impl_.pid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.PlayerUpdateResponse.pid)
}

// .webcamshooting.Player player = 2;
inline bool PlayerUpdateResponse::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool PlayerUpdateResponse::has_player() const {
  return _internal_has_player();
}
inline void PlayerUpdateResponse::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::webcamshooting::Player& PlayerUpdateResponse::_internal_player() const {
  const ::webcamshooting::Player* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::webcamshooting::Player&>(
      ::webcamshooting::_Player_default_instance_);
}
inline const ::webcamshooting::Player& PlayerUpdateResponse::player() const {
  // @@protoc_insertion_point(field_get:webcamshooting.PlayerUpdateResponse.player)
  return _internal_player();
}
inline void PlayerUpdateResponse::unsafe_arena_set_allocated_player(
    ::webcamshooting::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webcamshooting.PlayerUpdateResponse.player)
}
inline ::webcamshooting::Player* PlayerUpdateResponse::release_player() {
  
  ::webcamshooting::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::webcamshooting::Player* PlayerUpdateResponse::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:webcamshooting.PlayerUpdateResponse.player)
  
  ::webcamshooting::Player* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::webcamshooting::Player* PlayerUpdateResponse::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::webcamshooting::Player>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::webcamshooting::Player* PlayerUpdateResponse::mutable_player() {
  ::webcamshooting::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:webcamshooting.PlayerUpdateResponse.player)
  return _msg;
}
inline void PlayerUpdateResponse::set_allocated_player(::webcamshooting::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:webcamshooting.PlayerUpdateResponse.player)
}

// bool dead = 3;
inline void PlayerUpdateResponse::clear_dead() {
  _impl_.dead_ = false;
}
inline bool PlayerUpdateResponse::_internal_dead() const {
  return _impl_.dead_;
}
inline bool PlayerUpdateResponse::dead() const {
  // @@protoc_insertion_point(field_get:webcamshooting.PlayerUpdateResponse.dead)
  return _internal_dead();
}
inline void PlayerUpdateResponse::_internal_set_dead(bool value) {
  
  _impl_.dead_ = value;
}
inline void PlayerUpdateResponse::set_dead(bool value) {
  _internal_set_dead(value);
  // @@protoc_insertion_point(field_set:webcamshooting.PlayerUpdateResponse.dead)
}

// bool fired = 6;
inline void PlayerUpdateResponse::clear_fired() {
  _impl_.fired_ = false;
}
inline bool PlayerUpdateResponse::_internal_fired() const {
  return _impl_.fired_;
}
inline bool PlayerUpdateResponse::fired() const {
  // @@protoc_insertion_point(field_get:webcamshooting.PlayerUpdateResponse.fired)
  return _internal_fired();
}
inline void PlayerUpdateResponse::_internal_set_fired(bool value) {
  
  _impl_.fired_ = value;
}
inline void PlayerUpdateResponse::set_fired(bool value) {
  _internal_set_fired(value);
  // @@protoc_insertion_point(field_set:webcamshooting.PlayerUpdateResponse.fired)
}

// repeated .webcamshooting.DamageResponse damages = 7;
inline int PlayerUpdateResponse::_internal_damages_size() const {
  return _impl_.damages_.size();
}
inline int PlayerUpdateResponse::damages_size() const {
  return _internal_damages_size();
}
inline void PlayerUpdateResponse::clear_damages() {
  _impl_.damages_.Clear();
}
inline ::webcamshooting::DamageResponse* PlayerUpdateResponse::mutable_damages(int index) {
  // @@protoc_insertion_point(field_mutable:webcamshooting.PlayerUpdateResponse.damages)
  return _impl_.damages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::DamageResponse >*
PlayerUpdateResponse::mutable_damages() {
  // @@protoc_insertion_point(field_mutable_list:webcamshooting.PlayerUpdateResponse.damages)
  return &_impl_.damages_;
}
inline const ::webcamshooting::DamageResponse& PlayerUpdateResponse::_internal_damages(int index) const {
  return _impl_.damages_.Get(index);
}
inline const ::webcamshooting::DamageResponse& PlayerUpdateResponse::damages(int index) const {
  // @@protoc_insertion_point(field_get:webcamshooting.PlayerUpdateResponse.damages)
  return _internal_damages(index);
}
inline ::webcamshooting::DamageResponse* PlayerUpdateResponse::_internal_add_damages() {
  return _impl_.damages_.Add();
}
inline ::webcamshooting::DamageResponse* PlayerUpdateResponse::add_damages() {
  ::webcamshooting::DamageResponse* _add = _internal_add_damages();
  // @@protoc_insertion_point(field_add:webcamshooting.PlayerUpdateResponse.damages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::DamageResponse >&
PlayerUpdateResponse::damages() const {
  // @@protoc_insertion_point(field_list:webcamshooting.PlayerUpdateResponse.damages)
  return _impl_.damages_;
}

// -------------------------------------------------------------------

// UpdateResponse

// repeated .webcamshooting.PlayerUpdateResponse players = 1;
inline int UpdateResponse::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int UpdateResponse::players_size() const {
  return _internal_players_size();
}
inline void UpdateResponse::clear_players() {
  _impl_.players_.Clear();
}
inline ::webcamshooting::PlayerUpdateResponse* UpdateResponse::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:webcamshooting.UpdateResponse.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::PlayerUpdateResponse >*
UpdateResponse::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:webcamshooting.UpdateResponse.players)
  return &_impl_.players_;
}
inline const ::webcamshooting::PlayerUpdateResponse& UpdateResponse::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::webcamshooting::PlayerUpdateResponse& UpdateResponse::players(int index) const {
  // @@protoc_insertion_point(field_get:webcamshooting.UpdateResponse.players)
  return _internal_players(index);
}
inline ::webcamshooting::PlayerUpdateResponse* UpdateResponse::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::webcamshooting::PlayerUpdateResponse* UpdateResponse::add_players() {
  ::webcamshooting::PlayerUpdateResponse* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:webcamshooting.UpdateResponse.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webcamshooting::PlayerUpdateResponse >&
UpdateResponse::players() const {
  // @@protoc_insertion_point(field_list:webcamshooting.UpdateResponse.players)
  return _impl_.players_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace webcamshooting

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_game_2eproto
